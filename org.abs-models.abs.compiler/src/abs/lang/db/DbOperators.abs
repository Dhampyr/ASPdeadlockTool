module ABS.DB.Operators;

export *;

import * from ABS.DB.Structure;
import * from ABS.DB.Operators.Structure;
import * from ABS.DB.Helpers;

def Bool isGrouping(UnaryRelationalOperator operator) =
	case operator {
		Grouping(_, _) => True;
		_ => False;
	};

// Returns Error if the operation is invalid.
def MaybeEx<Relation> executeUnaryRelationalOperator(UnaryRelationalOperator operator, Relation operand) =
	case operator {
		Projection(attributes) => JustEx(projection(operand, attributes));
		Selection(condition) => JustEx(selection(operand, condition));
		DuplicateDeletion => JustEx(duplicateDeletion(operand));
		Renaming(map) => renaming(operand, map);
		Grouping(newAttributes, groupingAttributes) =>
			grouping(operand, newAttributes, groupingAttributes);
		GroupingAndProjection(newAttributes, groupingAttributes, projectionAttributes) =>
			groupingAndProjection(operand, newAttributes, groupingAttributes, projectionAttributes);
		Ordering(orderingAttributes) => JustEx(ordering(operand, orderingAttributes));
		Modification(modOperator) => executeRelationalModificationOperator(modOperator, operand);
	};

// newToOldNameMap must contain each name contained in newNameAttributes.
// oldMap must contain each attribute in newNameAttributes, but with its old name according to
// newToOldNameMap.
def Map<String, AggregateFunction> createAttrToFunctionMapWithNewNames(
		Map<String, String> newToOldNameMap, Set<String> newNames,
		Map<String, AggregateFunction> oldMap) =
	case newNames {
		Insert(newName, rest) =>
			InsertAssoc(
				Pair(
					newName,
					fromJust(lookup(oldMap, fromJust(lookup(newToOldNameMap, newName))))),
				createAttrToFunctionMapWithNewNames(newToOldNameMap, rest, oldMap));
		EmptySet => EmptyMap;
	}; 

def MaybeEx<Relation> executeBinaryRelationalOperator(BinaryRelationalOperator operator, Relation operand1, Relation operand2) =
	case operator {
		Join => JustEx(join(operand1, operand2));
		LeftJoin => JustEx(leftJoin(operand1, operand2));
		UnionAll => unionAll(operand1, operand2);
		Union =>
			case unionAll(operand1, operand2) {
				JustEx(result) => JustEx(duplicateDeletion(result));
				error => error;
			};
		Difference => difference(operand1, operand2);
		Intersection => intersection(operand1, operand2);
	};

// projection
def Relation projection(Relation relation, Set<AttributeRef> attributes) =
	let (RelationScheme scheme) = relationScheme(relation) in
		let (Set<Attribute> attrs) =  getAttributesByRefs(attributes, relationScheme(relation)) in
	Relation(relationName(relation),
		setIntersection(scheme, attrs),
		tupleListProjection(relationTuples(relation), attrs));

def List<Tuple> tupleListProjection(List<Tuple> tuples, Set<Attribute> attributes) =
	case tuples {
		Cons(t, rest) => Cons(
			tupleProjection(t, attributes),
			tupleListProjection(rest, attributes));
		Nil => tuples;
	};

def Tuple tupleProjection(Tuple tuple, Set<Attribute> attributes) =
	case tuple {
		InsertAssoc(pair, rest) =>
			let (Tuple processedRest) = tupleProjection(rest, attributes) in
				if contains(attributes, fst(pair)) then
					insert(processedRest, pair)
				else
					processedRest;
		empty => empty;
	};

// selection
def Relation selection(Relation relation, SelectionCondition condition) =
	Relation(relationName(relation), relationScheme(relation), tupleListSelection(relationTuples(relation), condition));

def List<Tuple> tupleListSelection(List<Tuple> tuples, SelectionCondition condition) =
	case tuples {
		Cons(t, rest) =>
			let (List<Tuple> processedRest) = tupleListSelection(rest, condition) in
				if conditionApplies(condition, t) then
					Cons(t, processedRest)
				else
					processedRest;
		Nil => tuples;
	};

def Bool conditionApplies(SelectionCondition condition, Tuple tuple) =
	case condition {
		NoCondition => True;
		ComparisonCondition(f1, relation, f2) =>
			relationContains(relation, applyScalarFunction(f1, tuple), applyScalarFunction(f2, tuple));
		CompositeCondition(c1, operator, c2) =>
			let (Bool b1) = conditionApplies(c1, tuple) in
			let (Bool b2) = conditionApplies(c2, tuple) in
				case operator {
					AND => b1 && b2;
					OR => b1 || b2;
				};
		IsNullCondition(attr) =>
			case lookupValueByAttrRef(tuple, attr) {
				Just(AttrNullVal) => True;
				Nothing => True;
				_ => False;
			};
		NegatedCondition(con) => ~ conditionApplies(con, tuple);
		TupleEqualityCondition(t) => mapsEquivalent(tupleProjection(tuple, keys(t)), t);
	};

def Bool relationContains(ComparisonRelation relation, AttributeValue val1, AttributeValue val2) =
	if (val1 == AttrNullVal || val2 == AttrNullVal) then
		False
	else
		case relation {
			CR_EQ => val1 == val2;
			CR_NEQ => val1 != val2;
			_ =>
				case val1 {
					AttrIntVal(i1) =>
						case val2 {
							AttrIntVal(i2) =>
								case relation {
									CR_LT => i1 < i2;
									CR_LEQ => i1 <= i2;
									CR_GT => i1 > i2;
									CR_GEQ => i1 >= i2;
								};
							_ => False;
						};
					_ => False;
				};
		};

// deduplication
def Relation duplicateDeletion(Relation relation) =
	Relation(
		relationName(relation),
		relationScheme(relation),
		tupleListduplicateDeletion(relationTuples(relation)));

def List<Tuple> tupleListduplicateDeletion(List<Tuple> tuples) =
	case tuples {
		Cons(t, rest) =>
			let (List<Tuple> processedRest) = tupleListduplicateDeletion(rest) in
			if listContains(processedRest, t) then
				processedRest
			else
				Cons(t, processedRest);
		Nil => tuples;
	};

// inner join
def Relation join(Relation relation1, Relation relation2) =
	let (RelationScheme scheme1) = relationScheme(relation1) in
	let (RelationScheme scheme2) = relationScheme(relation2) in
		Relation(relationName(relation1) + "><" + relationName(relation2),
			union(scheme1, scheme2),
			tupleListJoin(relationTuples(relation1), relationTuples(relation2), setIntersection(scheme1, scheme2)));

def List<Tuple> tupleListJoin(List<Tuple> tuples1, List<Tuple> tuples2, Set<Attribute> joinAttributes) =
	case tuples1 {
		Cons(t, rest) =>
			let (List<Tuple> processedRest) = tupleListJoin(rest, tuples2, joinAttributes) in
				concatenate(mergeTupleWithList(t, tuples2, tupleProjection(t, joinAttributes)), processedRest);
		Nil => tuples1;
	};

// The result contains a tuple (t, t2) for each t2 in tuples which matches mergeCriterion.
def List<Tuple> mergeTupleWithList(Tuple tuple, List<Tuple> tuples, Tuple mergeCriterion) =
	case tuples {
		Cons(t, rest) =>
			let (List<Tuple> processedRest) = mergeTupleWithList(tuple, rest, mergeCriterion) in
				if tupleMatches(t, mergeCriterion) then
					Cons(putMap(tuple, t), processedRest)
				else
					processedRest;
		Nil => tuples;
	};

// Returns true if tuple contains all attributes contained in criterion with the
// same values.
def Bool tupleMatches(Tuple tuple, Tuple criterion) =
	case criterion {
		InsertAssoc(pair, rest) =>
			lookup(tuple, fst(pair)) == Just(snd(pair)) &&
			tupleMatches(tuple, rest);
		EmptyMap => True;
	};

// left outer join
def Relation leftJoin(Relation relation1, Relation relation2) =
	let (RelationScheme scheme1) = relationScheme(relation1) in
	let (RelationScheme scheme2) = relationScheme(relation2) in
		Relation(relationName(relation1) + "><" + relationName(relation2),
			union(scheme1, scheme2),
			tupleListLeftJoin(relationTuples(relation1), relationTuples(relation2), setIntersection(scheme1, scheme2)));

def List<Tuple> tupleListLeftJoin(List<Tuple> tuples1, List<Tuple> tuples2, Set<Attribute> joinAttributes) =
	case tuples1 {
		Cons(t, rest) =>
			let (List<Tuple> processedRest) = tupleListLeftJoin(rest, tuples2, joinAttributes) in
				concatenate(
					mergeTupleWithListOuter(t, tuples2, tupleProjection(t, joinAttributes), False),
					processedRest);
		Nil => tuples1;
	};

// The result contains a tuple (t, t2) for each t2 in tuples which matches mergeCriterion.
// If no tuple in tuples matches mergeCriterion, then tuple itself is returned.
def List<Tuple> mergeTupleWithListOuter(Tuple tuple, List<Tuple> tuples, Tuple mergeCriterion,
		Bool found) =
	case tuples {
		Cons(t, rest) =>
			if tupleMatches(t, mergeCriterion) then
				Cons(putMap(tuple, t), mergeTupleWithListOuter(tuple, rest, mergeCriterion, True))
			else
				mergeTupleWithListOuter(tuple, rest, mergeCriterion, found);
		Nil =>
			if found then
				tuples
			else
				list[tuple];
	};

// rename
// Returns Error if an attribute with one of the new names already exists and is not renamed or
// if the name map is invalid.
def MaybeEx<Relation> renaming(Relation relation, Map<String, String> nameMap) =
	case assureNameMapValidity(nameMap) {
		JustEx(_) =>
			case let (RelationScheme scheme) = relationScheme(relation) in
					relationSchemeRenaming(scheme, nameMap, scheme) {
				JustEx(newScheme) =>
					JustEx(Relation(
						relationName(relation),
						newScheme,
						tupleListRenaming(relationTuples(relation), nameMap)));
				error => forwardError(error, "renaming");
			};
		error => forwardError(error, "renaming");
	};

def MaybeEx<Unit> assureNameMapValidity(Map<String, String> nameMap) =
	case nameMap {
		InsertAssoc(Pair(oldName, newName), rest) =>
			if listContains(values(rest), newName) then
				Error("assureNameMapValidity", "New name \"" + newName + "\" is contained twice in nameMap.")
			else if oldName == newName then
				Error("assureNameMapValidity", "Name \"" + oldName + "\" cannot be mapped to itself.")
			else
				assureNameMapValidity(rest);
		EmptyMap => JustEx(Unit);
	};

def MaybeEx<RelationScheme> relationSchemeRenaming(RelationScheme scheme, Map<String, String> nameMap,
		RelationScheme originalScheme) =
	case scheme {
		Insert(attr, rest) =>
			case relationSchemeRenaming(rest, nameMap, originalScheme) {
				JustEx(processedRest) =>
					case lookup(nameMap, fst(attr)) {
						Just(newName) =>
							if isJust(lookup(nameMap, newName)) ||
									~isJust(getPairByFst(originalScheme, newName)) then
								JustEx(Insert(Pair(newName, snd(attr)), processedRest))
							else
								Error("relationSchemeRenaming", "Attribute with name \"" + newName + "\" is already existing.");
						Nothing => JustEx(Insert(attr, processedRest));
					};
				error => error;
			};
		EmptySet => JustEx(scheme);
	};

def List<Tuple> tupleListRenaming(List<Tuple> tuples, Map<String, String> nameMap) =
	case tuples {
		Cons(t, rest) =>
			Cons(
				tupleRenaming(t, nameMap),
				tupleListRenaming(rest, nameMap));
		Nil => tuples;
	};

def Tuple tupleRenaming(Tuple tuple, Map<String, String> nameMap) =
	case tuple {
		InsertAssoc(p, rest) =>
			InsertAssoc(
				let (Attribute attr) = fst(p) in
				case lookup(nameMap, fst(attr)) {
					Just(newName) => Pair(Pair(newName, snd(attr)), snd(p));
					Nothing => p;
				},
				tupleRenaming(rest, nameMap));
		EmptyMap => tuple;
	};

// union all
// Returns Error if the relations do not have equal schemes.
def MaybeEx<Relation> unionAll(Relation relation1, Relation relation2) =
	let (RelationScheme scheme) = relationScheme(relation1) in
		if setsEquivalent(scheme, relationScheme(relation2)) then
			JustEx(Relation(
				relationName(relation1) + "+" + relationName(relation2),
				scheme,
				concatenate(
					relationTuples(relation1),
					relationTuples(relation2))))
		else
			Error("union", "Schemes of relation1 and relation2 are not equal: relation1(" + toString(scheme) + "), relation2(" + toString(relationScheme(relation2)) + ")");

// difference
// Returns Error if the relations do not have equal schemes.
def MaybeEx<Relation> difference(Relation relation1, Relation relation2) =
	let (RelationScheme scheme) = relationScheme(relation1) in
		if setsEquivalent(scheme, relationScheme(relation2)) then
			JustEx(Relation(
				relationName(relation1) + "-" + relationName(relation2),
				scheme,
				removeAll(relationTuples(relation1), relationTuples(relation2))))
		else
			Error("difference", "Schemes of relation1 and relation2 are not equal.");

// intersection
// Returns Error if the relations do not have equal schemes.
def MaybeEx<Relation> intersection(Relation relation1, Relation relation2) =
	let (RelationScheme scheme) = relationScheme(relation1) in
		if setsEquivalent(scheme, relationScheme(relation2)) then
			JustEx(Relation(
				relationName(relation1) + "^" + relationName(relation2),
				scheme,
				retainAll(relationTuples(relation1), relationTuples(relation2))))
		else
			Error("intersection", "Schemes of relation1 and relation2 are not equal.");


// grouping (SSH_DB 9.1)
// Returns Error if an attribute with the name of newAttribute is already existing in
// relation's scheme.
def MaybeEx<Relation> grouping(Relation relation, Map<String, AggregateFunction> newAttributes,
		Maybe<Set<AttributeRef>> groupingAttributes) =
	groupingIntern(relation, newAttributes,
		case groupingAttributes {
			Just(attributes) => attributes;
			Nothing => wrapAttributesInRefs(relationScheme(relation));
		});
				
def MaybeEx<Relation> groupingIntern(Relation relation, Map<String, AggregateFunction> newAttributes,
		Set<AttributeRef> groupingAttributes) =
	case newAttributes {
		InsertAssoc(Pair(attributeName, function), rest) =>
			case groupingOneAttribute(relation, attributeName, function, groupingAttributes) {
				JustEx(newRelation) => groupingIntern(newRelation, rest, groupingAttributes);
				error => error;
			};
		EmptyMap => JustEx(relation);
	};

def MaybeEx<Relation> groupingOneAttribute(Relation relation, String newAttributeName,
		AggregateFunction function, Set<AttributeRef> groupingAttributes) =
	let (RelationScheme scheme) = relationScheme(relation) in
	if isJust(getPairByFst(scheme, newAttributeName)) then // name of newAttribute not new
		Error("grouping", "An attribute with name \"" + newAttributeName + "\" is already existing.")
	else
		case getAggregateFunctionType(function, scheme) {
			JustEx(attrType) =>
				let (Attribute newAttribute) = Pair(newAttributeName, attrType) in
				JustEx(Relation(relationName(relation),
					Insert(newAttribute, scheme),
					let (List<Tuple> tuples) = relationTuples(relation) in
						applyAggregateFunctionToTupleGroups(
							tuples,
							newAttribute,
							function,
							getAttributesByRefs(groupingAttributes, scheme))));
			error => forwardError(error, "groupingOneAttribute");
		};

def MaybeEx<AttributeType> getAggregateFunctionType(AggregateFunction function, RelationScheme scheme) =
	case function {
		Maximum(tupleFunction) => getTupleScalarFunctionType(tupleFunction, scheme);
		Minimum(tupleFunction) => getTupleScalarFunctionType(tupleFunction, scheme);
		AggregateSum(tupleFunction) => getTupleScalarFunctionType(tupleFunction, scheme);
		Average(tupleFunction) => getTupleScalarFunctionType(tupleFunction, scheme);
		Unique(tupleFunction) => getTupleScalarFunctionType(tupleFunction, scheme);
		AggregateConstant(value) => JustEx(getAttributeTypeOfValue(value));
		Count => JustEx(AttrInt);
	};

def MaybeEx<AttributeType> getTupleScalarFunctionType(TupleScalarFunction function, RelationScheme scheme) =
	case function {
		TupleAttributeValue(attrRef) =>
			case getAttributeByRef(attrRef, scheme) {
				Just(attribute) => JustEx(snd(attribute));
				Nothing => Error("getTupleScalarFunctionType", "Referenced attribute \"" + attributeRefToString(attrRef) + "\" not existing in scheme.");
			};
		TupleBinaryFunction(operator, _, _) => JustEx(getAttributeTypeForOperator(operator));
		TupleConstant(value) => JustEx(getAttributeTypeOfValue(value));
		TupleCaseFunction(_, elseFun) => getTupleScalarFunctionType(elseFun, scheme);
	};

def List<Tuple> applyAggregateFunctionToTupleGroups(List<Tuple> tuples, Attribute newAttribute, // TODO test
		AggregateFunction function, Set<Attribute> groupingAttributes) =
	case tuples {
		Cons(t, rest) =>
			let (List<Tuple> tupleGroup) = tupleListSelection(
				tuples,
				TupleEqualityCondition(tupleProjection(t, groupingAttributes))) in
			concatenate(
				extendTuplesWithAttribute(tupleGroup, newAttribute, applyAggregateFunction(function, tupleGroup)),
				applyAggregateFunctionToTupleGroups(
					removeAll(rest, tail(tupleGroup)),
					newAttribute,
					function,
					groupingAttributes));
		Nil => tuples;
	};

def List<Tuple> extendTuplesWithAttribute(List<Tuple> tuples, Attribute newAttribute, AttributeValue value) =
	case tuples {
		Cons(t, rest) =>
			Cons(
				put(t, newAttribute, value),
				extendTuplesWithAttribute(rest, newAttribute, value));
		Nil => tuples;
	};

def AttributeValue applyAggregateFunction(AggregateFunction function, List<Tuple> tuples) =
	case function {
		Maximum(f) => tupleMaximum(tuples, f);
		Minimum(f) => tupleMinimum(tuples, f);
		AggregateSum(f) => tupleSum(tuples, f);
		Average(f) => tupleAverage(tuples, f);
		Unique(f) => tupleUnique(tuples, f);
		AggregateConstant(v) => v;
		Count => AttrIntVal(length(tuples));
	};

def AttributeValue tupleMaximum(List<Tuple> tuples, TupleScalarFunction function) =
	case tuples {
		Cons(t, rest) =>
			let (AttributeValue restMax) = tupleMaximum(rest, function) in
				case applyScalarFunction(function, t) {
					AttrIntVal(i) =>
						case restMax {
							AttrIntVal(restI) =>
								if i > restI then
									AttrIntVal(i)
								else
									restMax;
							_ => AttrIntVal(i);
						};
					_ => restMax;
				};
		Nil => AttrNullVal;
	};

def AttributeValue tupleMinimum(List<Tuple> tuples, TupleScalarFunction function) =
	case tuples {
		Cons(t, rest) =>
			let (AttributeValue restMin) = tupleMinimum(rest, function) in
				case applyScalarFunction(function, t) {
					AttrIntVal(i) =>
						case restMin {
							AttrIntVal(restI) =>
								if i < restI then
									AttrIntVal(i)
								else
									restMin;
							_ => AttrIntVal(i);
						};
					_ => restMin;
				};
		Nil => AttrNullVal;
	};

def AttributeValue tupleSum(List<Tuple> tuples, TupleScalarFunction function) =
	case tuples {
		Cons(t, rest) =>
			let (AttributeValue restSum) = tupleSum(rest, function) in
				case applyScalarFunction(function, t) {
					AttrIntVal(i) =>
						case restSum {
							AttrIntVal(restI) => AttrIntVal(i + restI);
							_ => AttrIntVal(i);
						};
					_ => restSum;
				};
		Nil => AttrNullVal;
	};

def AttributeValue tupleAverage(List<Tuple> tuples, TupleScalarFunction function) =
	let (Int size) = length(tuples) in
		if size <= 0 then
			AttrNullVal
		else
			case tupleSum(tuples, function) {
				AttrIntVal(sum) => AttrIntVal(sum / size);
				_ => AttrNullVal;
			};	

def AttributeValue tupleUnique(List<Tuple> tuples, TupleScalarFunction function) =
	case tuples {
		Cons(tuple, rest) =>
			if isEmpty(rest) then
				applyScalarFunction(function, tuple)
			else
				let (AttributeValue restVal) = tupleUnique(rest, function) in
				if restVal == AttrNullVal || applyScalarFunction(function, tuple) == restVal then
					restVal
				else
					AttrNullVal;
		Nil => AttrNullVal;
	};

def AttributeValue applyScalarFunction(TupleScalarFunction function, Tuple tuple) =
	case function {
		TupleAttributeValue(a) =>
			case lookupValueByAttrRef(tuple, a) {
				Just(v) => v;
				Nothing => AttrNullVal;
			};
		TupleBinaryFunction(operator, f1, f2) =>
			applyValueOperator(operator, applyScalarFunction(f1, tuple), applyScalarFunction(f2, tuple));
		TupleConstant(v) => v;
		TupleCaseFunction(conditionMap, elseFun) => applyCaseConditionMap(conditionMap, elseFun, tuple);
	};

def AttributeValue applyValueOperator(AttributeValueOperator operator, AttributeValue operand1,
		AttributeValue operand2) =
	if operator == ValueConcatenation then
		if operand1 == AttrNullVal || operand2 == AttrNullVal then
			AttrNullVal
		else
			AttrStringVal(attributeValueToString(operand1) +
				attributeValueToString(operand2))
	else
		case operand1 {
			AttrIntVal(i1) =>
				case operand2 {
					AttrIntVal(i2) => AttrIntVal(
						case operator {
							ValueSum => i1 + i2;
							ValueDifference => i1 - i2;
							ValueProduct => i1 * i2;
							ValueQuotient => i1 / i2;
						});
					_ => AttrNullVal;
				};
			_ => AttrNullVal;
		};

def String attributeValueToString(AttributeValue value) =
	case value {
		AttrStringVal(s) => s;
		AttrIntVal(i) => intToString(i);
		AttrBoolVal(b) => if b then "1" else "0";
		AttrNullVal => "";
	};

def AttributeValue applyCaseConditionMap(Map<SelectionCondition, TupleScalarFunction> map,
		TupleScalarFunction elseFunction, Tuple tuple) =
	case map {
		InsertAssoc(Pair(condition, function), rest) =>
			if conditionApplies(condition, tuple) then
				applyScalarFunction(function, tuple)
			else
				applyCaseConditionMap(rest, elseFunction, tuple);
		EmptyMap => applyScalarFunction(elseFunction, tuple);
	};

// See executeUnaryRelationalOperator.
def MaybeEx<Relation> groupingAndProjection(Relation relation, Map<String, AggregateFunction> newAttributes,
		Maybe<Set<AttributeRef>> groupingAttributes, Set<AttributeRef> projectionAttributes) =
	case createNewAttributeNames(keys(newAttributes), relationScheme(relation)) {
		Pair(newNames, nameMap) =>
			case grouping(
					relation,
					createAttrToFunctionMapWithNewNames(
						nameMap, newNames, newAttributes),
					groupingAttributes) {
				JustEx(relationAfterGrouping) =>
					let (Set<AttributeRef> newAttrRefs) = createAttributeRefsFromNames(newNames) in
					renaming(
						projection(
							case groupingAttributes {
								Just(theGroupingAttributes) =>
									duplicateDeletion(projection(
										relationAfterGrouping,
										union(
											newAttrRefs,
											theGroupingAttributes)));
								Nothing => relationAfterGrouping;
							},
							union(newAttrRefs, projectionAttributes)),
						nameMap);
				error => error;
			};
	};
// ordering
def Relation ordering(Relation relation, List<Pair<AttributeRef, Bool>> orderingAttributes) =
	Relation(
		relationName(relation),
		relationScheme(relation),
		tupleListOrdering(relationTuples(relation), orderingAttributes));

def List<Tuple> tupleListOrdering(List<Tuple> tuples, List<Pair<AttributeRef, Bool>> orderingAttributes) =
	case tuples {
		Cons(t, rest) =>
			orderedInsertion(tupleListOrdering(rest, orderingAttributes), t, orderingAttributes);
		Nil => tuples;
	};

def List<Tuple> orderedInsertion(List<Tuple> tuples, Tuple tuple, List<Pair<AttributeRef, Bool>> orderingAttributes) =
	case tuples {
		Cons(t, rest) =>
			if tupleIsGreater(tuple, t, orderingAttributes) then
				Cons(t, orderedInsertion(rest, tuple, orderingAttributes))
			else
				Cons(tuple, tuples);
		Nil => list[tuple];
	};

def Bool tupleIsGreater(Tuple tuple1, Tuple tuple2, List<Pair<AttributeRef, Bool>> orderingAttributes) =
	case orderingAttributes {
		Cons(Pair(attrRef, asc), rest) =>
			let (Int compareValue) = compareValues(
				lookupValueByAttrRef(tuple1, attrRef),
				lookupValueByAttrRef(tuple2, attrRef)) in
			if compareValue == 0 then
				tupleIsGreater(tuple1, tuple2, rest)
			else if compareValue > 0 then
				asc
			else
				~asc;
		Nil => False;
	};

// Returns -1 if val1 < val2 or if val2 is null/Nothing and val1 not.
// Returns 0 if val1 == val2 or val1, val2 are not comparable.
// Returns 1 if val1 > val2 or if val1 is null/Nothing and val2 not.
def Int compareValues(Maybe<AttributeValue> maybeVal1, Maybe<AttributeValue> maybeVal2) =
	case maybeVal1 {
		Just(AttrNullVal) =>
			case maybeVal2 {
				Just(AttrNullVal) => 0;
				Just(_) => 1;
				Nothing => 0;
			};
		Just(val1) =>
			case maybeVal2 {
				Just(AttrNullVal) => -1;
				Just(AttrIntVal(v2)) =>
					case val1 {
						AttrIntVal(v1) =>
							if v1 < v2 then
								-1
							else if v1 == v2 then
								0
							else
								1;
						_ => 0;
					};
				Just(AttrBoolVal(v2)) =>
					case val1 {
						AttrBoolVal(v1) =>
							if v1 == v2 then
								0
							else if v1 then
								1
							else
								-1;
						_ => 0;
					};
				Nothing => -1;
				_ => 0;
			};
		Nothing =>
			case maybeVal2 {
				Just(AttrNullVal) => 0;
				Just(_) => 1;
				Nothing => 0;
			};
	};

// SSH_DB 4.3.2: Modifying relational algebra --------------------------------------------------------
// Error is returned if the operation is invalid.
def MaybeEx<Relation> executeRelationalModificationOperator(RelationalModificationOperator operator,
		Relation operand) =
	case operator {
		InsertionTuple(tuple) => insertion(operand, tuple);
		Insertion(values) => insertionByAttrRef(operand, values);
		Deletion(condition) => JustEx(deletion(operand, condition));
		Update(condition, map) => update(operand, condition, map);
	};

// Equivalent to executeModificationRelationalOperator, but ensures that the conditions defined
// by exRelationScheme are not violated.
def MaybeEx<Relation> executeRelationalModificationOperatorSafe(RelationalModificationOperator operator,
		Relation operand,
		ExtendedRelationScheme exRelationScheme) =
	case executeRelationalModificationOperator(operator, operand) {
		JustEx(relation) =>
			if length(tupleListduplicateDeletion(relationTuples(projection(relation, wrapAttributesInRefs(snd(exRelationScheme)))))) ==
					length(relationTuples(relation)) then
				JustEx(relation)
			else
				Error("executeRelationalModificationOperatorSafe", "Primary key uniqueness violated");
		error => error;
	};

// insertion
// Error is returned if tuple does not match relation's scheme.
def MaybeEx<Relation> insertion(Relation relation, Tuple tuple) =
	let (RelationScheme scheme) = relationScheme(relation) in
		case tupleMatchesScheme(tuple, scheme) {
			JustEx(_) =>
				JustEx(Relation(
					relationName(relation),
					scheme,
					Cons(tuple, relationTuples(relation))));
			error => forwardError(error, "insertion");
		};

// Error is returned if one of the value names does not occur in the scheme as attribute name.
def MaybeEx<Relation> insertionValues(Relation relation, Map<String, AttributeValue> values) =
	case createTupleFromValues(relationScheme(relation), values) {
		JustEx(tuple) => insertion(relation, tuple);
		error => forwardError(error, "insertionValues");
	};

// Error is returned if one of the value names does not occur in the scheme as attribute name.
def MaybeEx<Tuple> createTupleFromValues(RelationScheme scheme, Map<String, AttributeValue> values) =
	case values {
		InsertAssoc(Pair(name, value), rest) =>
			case getPairByFst(scheme, name) {
				Just(attr) =>
					case createTupleFromValues(scheme, rest) {
						JustEx(restTuple) => JustEx(InsertAssoc(Pair(attr, value), restTuple));
						error => error;
					};
				Nothing => Error("createTupleFromValues", "Attribute with name \"" + name + "\" does not exist.");
			};
		_ => JustEx(EmptyMap);
	};

// Error is returned if one of the value names does not occur in the scheme as attribute name.
def MaybeEx<Relation> insertionByAttrRef(Relation relation, Map<AttributeRef, AttributeValue> values) =
	case createTupleFromAttributeValues(relationScheme(relation), values) {
		JustEx(tuple) => insertion(relation, tuple);
		error => forwardError(error, "createTupleFromAttributeValues");
	};

// Error is returned if not all of the AttributeRefs reference an existing attribute in the scheme.
def MaybeEx<Tuple> createTupleFromAttributeValues(RelationScheme scheme,
		Map<AttributeRef, AttributeValue> values) =
	case values {
		InsertAssoc(Pair(attrRef, value), rest) =>
			case getAttributeByRef(attrRef, scheme) {
				Just(attr) =>
					case createTupleFromAttributeValues(scheme, rest) {
						JustEx(restTuple) => JustEx(InsertAssoc(Pair(attr, value), restTuple));
						error => error;
					};
				Nothing => Error("createTupleFromAttributeValues", "AttributeRef does not reference an existing attribute.");
			};
		_ => JustEx(EmptyMap);
	};

// deletion
def Relation deletion(Relation relation, SelectionCondition condition) =
	selection(relation, NegatedCondition(condition));

// update
// Returns Error if relation's scheme does not contain the given attribute.
def MaybeEx<Relation> update(Relation relation, SelectionCondition condition,
		Map<AttributeRef, TupleScalarFunction> functions) =
	let (RelationScheme scheme) = relationScheme(relation) in
	case convertAttrRefToAttrMap(scheme, functions) {
		JustEx(convertedFunctions) =>
			JustEx(Relation(
				relationName(relation),
				relationScheme(relation),
				tupleListUpdate(relationTuples(relation), condition, convertedFunctions)));
		error => forwardError(error, "update");
	};

def MaybeEx<Map<Attribute, A>> convertAttrRefToAttrMap<A>(RelationScheme scheme,
		Map<AttributeRef, A> attrMap) =
	case attrMap {
		InsertAssoc(Pair(attrRef, x), rest) =>
			case getAttributeByRef(attrRef, scheme) {
				Just(attr) =>
					if contains(scheme, attr) then
						case convertAttrRefToAttrMap(scheme, rest) {
							JustEx(processedRest) => JustEx(InsertAssoc(Pair(attr, x), processedRest));
							error => error;
						}
					else
						Error("checkSchemeContainsAllAttributes", "relation's scheme does not contain the attribute \"" + attributeToString(attr) + "\".");
				Nothing => Error("checkSchemeContainsAllAttributes", "relation's scheme does not contain the attribute \"" + attributeRefToString(attrRef) + "\".");
			};
		EmptyMap => JustEx(EmptyMap);
	};

def List<Tuple> tupleListUpdate(List<Tuple> tuples, SelectionCondition condition,
		Map<Attribute, TupleScalarFunction> functions) =
	case tuples {
		Cons(t, rest) =>
			Cons(
				if conditionApplies(condition, t) then
					tupleUpdate(t, functions, t)
				else
					t,
				tupleListUpdate(rest, condition, functions));
		Nil => tuples;
	};

def Tuple tupleUpdate(Tuple tuple, Map<Attribute, TupleScalarFunction> functions, Tuple originalTuple) =
	case functions {
		InsertAssoc(Pair(attribute, function), rest) =>
			tupleUpdate(
				put(tuple, attribute, applyScalarFunction(function, originalTuple)),
				rest,
				originalTuple);
		EmptyMap => tuple;
	};


// Database value level =======================================================
// modifying operations

def MaybeEx<DatabaseValue> executeDbModificationOperatorSafe(DbModificationOperator operator,
		DatabaseValue operand, Map<String, ExtendedRelationScheme> exRelationSchemes) =
	case operator {
		RelationalModification(relationName, relOperator) =>
			case getRelationByName(operand, relationName) {
				Just(relation) =>
					case executeRelationalModificationOperatorSafe(
							relOperator,
							relation,
							fromJust(lookup(exRelationSchemes, relationName))) {
						JustEx(newRelation) =>
							JustEx(Insert(newRelation, remove(operand, relation)));
						error => forwardError(error, "executeDbModificationOperatorSafe");
					};
				Nothing => Error("executeDbModificationOperatorSafe", "relationName not in operand");
			};
	};