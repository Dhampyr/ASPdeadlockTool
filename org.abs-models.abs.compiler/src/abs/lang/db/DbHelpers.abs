module ABS.DB.Helpers;

export *;

import * from ABS.DB.Structure;
import * from ABS.DB.Operators.Structure;
import projection, duplicateDeletion from ABS.DB.Operators;

// Data type for propagating errors:
data MaybeEx<T> =
	JustEx(T) |
	// method name and error message
	Error(String, String);

def MaybeEx<U> forwardError<T, U>(MaybeEx<T> maybe, String methodName) =
	case maybe {
		JustEx(_) => Error("forwardError", "Cannot forward JustEx.");
		Error(method, msg) => Error(method + " -> " + methodName, msg);
	};

def MaybeEx<T> errorOnNothing<T>(Maybe<T> maybe, String method, String msg) =
	case maybe {
		Just(x) => JustEx(x);
		Nothing => Error(method, msg);
	};

def T fromJustEx<T>(MaybeEx<T> maybe) =
	case maybe {
		JustEx(x) => x;
	};

def Bool isJustEx<T>(MaybeEx<T> maybe) =
	case maybe {
		JustEx(_) => True;
		_ => False;
	};


def Bool setsEquivalent<A>(Set<A> set1, Set<A> set2) =
	case set1 {
		Insert(x, rest) =>
			contains(set2, x) &&
			setsEquivalent(rest, ABS.StdLib.remove(set2, x));
		empty => set2 == empty;
	};

def Set<A> setDifference<A>(Set<A> minuend, Set<A> subtrahend) =
	case minuend {
		Insert(x, rest) =>
			let (Set<A> processedRest) = setDifference(rest, subtrahend) in
				if contains(subtrahend, x) then
					processedRest
				else
					Insert(x, processedRest);
		empty => empty;
	};

def Set<A> setIntersection<A>(Set<A> a, Set<A> b) =
	case a {
		Insert(x, rest) =>
			let (Set<A> processedRest) = setIntersection(rest, b) in
				if contains(b, x) then
					Insert(x, processedRest)
				else
					processedRest;
		empty => empty;
	};

def Maybe<B> setLookupMaybe<A, B>(Set<Pair<A, B>> set, A key) =
	case set {
		Insert(Pair(key, value), _) => Just(value);
		Insert(_, rest) => setLookupMaybe(rest, key);
		EmptySet => Nothing;
	};

def Bool listContains<A>(List<A> list, A value) =
	case list {
		Cons(value, _) => True;
		Cons(_, rest) => listContains(rest, value);
		Nil => False;
	};

def List<A> removeAll<A>(List<A> list, List<A> subtrahend) =
	case subtrahend {
		Cons(a, rest) => removeAll(fst(listRemove(list, a)), rest);
		Nil => list;
	};

// Returns (l, true) if a was removed (once) from list, producing l.
// Returns (list, false) if a is not contained in list.
def Pair<List<A>, Bool> listRemove<A>(List<A> list, A a) =
	case list {
		Cons(a, rest) => Pair(rest, True);
		Cons(notA, rest) =>
			case listRemove(rest, a) {
				Pair(l, success) => Pair(Cons(notA, l), success);
			};
		Nil => Pair(list, False);
	};

def List<A> retainAll<A>(List<A> list1, List<A> list2) =
	case list1 {
		Cons(a, rest1) =>
			case listRemove(list2, a) {
				Pair(newList2, True) => Cons(a, retainAll(rest1, newList2));
				Pair(_, False) => retainAll(rest1, list2);
			};
		Nil => list1;
	};

def Map<A, B> putMap<A, B>(Map<A, B> map1, Map<A, B> map2) =
	case map1 {
		InsertAssoc(pair, rest) =>
			put(putMap(rest, map2), fst(pair), snd(pair));
		_ => map2;
	};

def Bool mapsEquivalent<A, B>(Map<A, B> map1, Map<A, B> map2) =
	case map1 {
		InsertAssoc(Pair(a, b), rest) =>
			lookup(map2, a) == Just(b) &&
			mapsEquivalent(rest, removeKey(map2, a));
		_ => map1 == map2;
	};

def Bool setContainsEquivalentMap<A, B>(Set<Map<A, B>> set, Map<A, B> map) =
	case set {
		Insert(x, rest) =>
			mapsEquivalent(x, map) || setContainsEquivalentMap(rest, map);
		_ => False;
	};

def Maybe<Pair<A, B>> getPairByFst<A, B>(Set<Pair<A, B>> pairSet, A fst) =
	case pairSet {
		Insert(p, rest) =>
			case p {
				Pair(fst, _) => Just(p);
				_ => getPairByFst(rest, fst);
			};
		_ => Nothing;
	};

def Set<Pair<A, B>> filterPairsByFst<A, B>(Set<Pair<A, B>> set, Set<A> values) =
	case values {
		Insert(x, rest) =>
			let (Set<Pair<A, B>> processedRest) = filterPairsByFst(set, rest) in
				case getPairByFst(set, x) {
					Just(p) => Insert(p, processedRest);
					_ => processedRest;
				};
		_ => EmptySet;
	};


// Returns Error if tuple defines a value for an attribute which does not occur in scheme or which
// does not match the attribute's type.
def MaybeEx<Unit> tupleMatchesScheme(Tuple tuple, RelationScheme scheme) =
	case tuple {
		InsertAssoc(Pair(attr, value), rest) =>
			if contains(scheme, attr) then
				let (AttributeType attrType) = snd(attr) in
				if attrValueMatchesType(value, attrType) then
					tupleMatchesScheme(rest, scheme)
				else
					Error("tupleMatchesScheme", "Value for attribute \"" + fst(attr) + "\" does not match declared type \"" + attributeTypeToString(attrType) + "\".")
			else
				Error("tupleMatchesScheme", "scheme does not contain attribute \"" + fst(attr) + "\".");
		_ => JustEx(Unit);
	};

def Bool attrValueMatchesType(AttributeValue attrValue, AttributeType attrType) =
	case Pair(attrValue, attrType) {
		Pair(AttrStringVal(_), AttrString) => True;
		Pair(AttrIntVal(_), AttrInt) => True;
		Pair(AttrBoolVal(_), AttrBool) => True;
		Pair(AttrNullVal, _) => True;
		_ => False;
	};

def Maybe<Relation> getRelationByName(Set<Relation> relations, String name) =
	case relations {
		Insert(relation, rest) =>
			if relationName(relation) == name then
				Just(relation)
			else
				getRelationByName(rest, name);
		EmptySet => Nothing;
	};

def Maybe<Attribute> getAttributeByRef(AttributeRef ref, RelationScheme scheme) =
	case ref {
		DirectAttributeRef(attr) => Just(attr);
		AttributeRefByName(name) => getPairByFst(scheme, name);
	};

def Set<Attribute> getAttributesByRefs(Set<AttributeRef> refs, RelationScheme scheme) =
	case refs {
		Insert(ref, rest) =>
			let (Set<Attribute> processedRest) = getAttributesByRefs(rest, scheme) in
				case getAttributeByRef(ref, scheme) {
					Just(attr) => Insert(attr, processedRest);
					_ => processedRest;
				};
		_ => EmptySet;
	};

def Maybe<AttributeValue> lookupValueByAttrRef(Tuple tuple, AttributeRef ref) =
	case ref {
		DirectAttributeRef(attr) => lookup(tuple, attr);
		AttributeRefByName(name) => lookupValueByAttributeName(tuple, name);
	};

def Maybe<AttributeValue> lookupValueByAttributeName(Tuple tuple, String name) =
	case tuple {
		InsertAssoc(Pair(Pair(n, _), value), rest) =>
			if n == name then
				Just(value)
			else
				lookupValueByAttributeName(rest, name);
		_ => Nothing;
	};

def Set<AttributeRef> wrapAttributesInRefs(Set<Attribute> attributes) =
	case attributes {
		Insert(x, rest) => Insert(DirectAttributeRef(x), wrapAttributesInRefs(rest));
		EmptySet => EmptySet;
	};

def Set<AttributeRef> createAttributeRefsFromNames(Set<String> names) =
	case names {
		Insert(name, rest) =>
			Insert(AttributeRefByName(name), createAttributeRefsFromNames(rest));
		EmptySet => EmptySet;
	};

// Returns Pair(newNames, renamingMap) where newNames equals names except that names are set
// to Strings not occurring in scheme, and renamingMap contains a mapping from the new names to
// the original names in names.
def Pair<Set<String>, Map<String, String>> createNewAttributeNames(Set<String> names,
		RelationScheme scheme) =
	createNewAttributeNamesIntern(names, scheme, 1);

def Pair<Set<String>, Map<String, String>> createNewAttributeNamesIntern(Set<String> names,
		RelationScheme scheme, Int nextNewIndex) =
	case names {
		Insert(oldName, rest) =>
			let (String newName) = "_attribute" + intToString(nextNewIndex) in
			if isJust(getPairByFst(scheme, newName)) then
				createNewAttributeNamesIntern(names, scheme, nextNewIndex + 1)
			else
				case createNewAttributeNamesIntern(rest, scheme, nextNewIndex + 1) {
					Pair(newNames, map) =>
						Pair(
							Insert(newName, newNames),
							InsertAssoc(Pair(newName, oldName), map));
				};
		EmptySet => Pair(names, EmptyMap);
	};


// Returns -1 if the relation size is not available.
def Int relationSize(Relation relation) =
	length(relationTuples(relation));

def Int countDifferentValues(Relation relation, Set<Attribute> attributes) =
	relationSize(duplicateDeletion(
		projection(relation, wrapAttributesInRefs(attributes))));

def Relation emptyRelation() = createRelation("[empty]", EmptySet);

def Relation createRelation(String name, RelationScheme scheme) =
	Relation(name, scheme, Nil);