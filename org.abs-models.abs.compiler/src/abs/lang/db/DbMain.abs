module ABS.DB;

export *;

import * from ABS.DB.Structure;
import * from ABS.DB.Operators;
import * from ABS.DB.Operators.Structure;
import * from ABS.DB.Helpers;
import * from ABS.DB.Transactions;
import * from ABS.DB.Listener;
import * from ABS.DB.Costs;

// Database behavior --------------------------------------------------------

// UnaryExecutionNode: UnaryDbOperation operation, ExecutionTree child
// BinaryExecutionNode: UnaryDbOperation operation, ExecutionTree child1, ExecutionTree child2
// RelationLeaf: String relationName
data ExecutionTree =
	UnaryExecutionNode(UnaryRelationalOperator, ExecutionTree) |
	BinaryExecutionNode(BinaryRelationalOperator, ExecutionTree, ExecutionTree) |
	RelationLeaf(String) |
	DirectRelationLeaf(Relation);

def String executionTreeToString(ExecutionTree tree) =
	case tree {
		UnaryExecutionNode(_, subTree) => "UnaryExecutionNode(" + executionTreeToString(subTree) + ")";
		BinaryExecutionNode(_, subTree1, subTree2) => "BinaryExecutionNode(" + executionTreeToString(subTree1) + ", " + executionTreeToString(subTree2) + ")";
		RelationLeaf(relation) => "RelationLeaf(" + relation + ")";
		DirectRelationLeaf(relation) => "DirectRelationLeaf(" + relationName(relation) + ")";
		ABS.DB.UnaryExecutionNode(_, _) => "ABS.DB.UnaryExecutionNode";
		_ => "Unknown";
	};

def Bool isUnaryExecutionNode(ExecutionTree tree) =
	case tree {
		UnaryExecutionNode(_, _) => True;
		_ => False;
	};

def Bool isBinaryExecutionNode(ExecutionTree tree) =
	case tree {
		BinaryExecutionNode(_, _, _) => True;
		_ => False;
	};

def Bool isRelationLeafNode(ExecutionTree tree) =
	case tree {
		RelationLeaf(_) => True;
		DirectRelationLeaf(_) => True;
		_ => False;
	};

def UnaryRelationalOperator getUnaryRelationalOperator(ExecutionTree tree) =
	case tree {
		UnaryExecutionNode(op, _) => op;
	};

def ExecutionTree getUnaryNodeChildTree(ExecutionTree tree) =
	case tree {
		UnaryExecutionNode(_, t) => t;
	};

def BinaryRelationalOperator getBinaryRelationalOperator(ExecutionTree tree) =
	case tree {
		BinaryExecutionNode(op, _, _) => op;
	};

def Pair<ExecutionTree, ExecutionTree> getBinaryNodeChildTrees(ExecutionTree tree) =
	case tree {
		BinaryExecutionNode(_, t1, t2) => Pair(t1, t2);
	};

def MaybeEx<Relation> getRelationForLeaf(ExecutionTree tree, DatabaseValue dbState) =
	case
		case tree {
			RelationLeaf(name) => errorOnNothing(
				getRelationByName(dbState, name),
				"getRelationForLeaf",
				"There is no relation with name \"" + name + "\".");
			DirectRelationLeaf(relation) => JustEx(relation);
		} {
		JustEx(relation) => JustEx(removeTupleIds(relation));
		error => error;
	};

def String getRelationLeafName(ExecutionTree tree) =
	case tree {
		RelationLeaf(name) => name;
	};

// This database model considers all database data to be located on one host.
interface RelationalDatabase {

	// Returns Error if some operation is invalid.
	MaybeEx<Relation> executeTree(ExecutionTree tree);
	
	// Returns Error if the operation failed.
	MaybeEx<Unit> modify(DbModificationOperator operator);
	
	// Adds a listener which will be called when tree execution nodes are executed in the database.
	[Atomic] Unit addListener(DatabaseExecutionListener listener);
	
	[Atomic] Unit removeListener(DatabaseExecutionListener listener);

}

// Interface for the transactional DB setting
interface RelationalTransactionalDatabase extends RelationalDatabase {

	Transaction beginTransaction();
	// failFast: see ConsTransaction
	Transaction beginTransactionFailFast(Bool failFast);
	// Waits for the current statement to finish and then commits the transaction.
	// Returns an Error if committing fails.
	MaybeEx<Unit> commitTransaction(Transaction transaction);
	// Waits for the current statement to finish and then aborts the transaction.
	Unit abortTransaction(Transaction transaction);
	
	MaybeEx<Relation> executeTreeInTransaction(ExecutionTree tree, Transaction transaction);
	// If failFast is True for the transaction, then the method will return with Error immediately
	// if some required lock is currently hold by another transaction. Otherwise, it will wait
	// until the lock can be obtained. If a lock will never be available again for this transaction
	// (i.e., it is forbidden), then Error is always returned immediately.
	// Note that a failure of single modify action does not harm the previously executed
	// operations of this transaction.
	MaybeEx<Unit> modifyInTransaction(DbModificationOperator operator, Transaction transaction);

}
	
def Set<Relation> createRelationsForSchemes(Map<String, ExtendedRelationScheme> schemes) =
	case schemes {
		InsertAssoc(Pair(name, scheme), rest) =>
			Insert(createRelation(name, fst(scheme)),
				createRelationsForSchemes(rest));
		EmptyMap => EmptySet;
	};

//class RelationalDatabase([Final] DatabaseScheme scheme, [Final] List<String> relationNames) implements RelationalDatabase {
// relationSchemes assign schemes to relation names.
class RelationalDatabase(DatabaseScheme scheme) implements RelationalTransactionalDatabase {
	
	// Invariant:
	// (1) For each name of a relation in database, there is exactly one entry in relationSchemes
	//     and vice versa.
	DatabaseValue database = EmptySet;

	// time is increased whenever a new transaction is created or an existing transaction
	// is committed.
	Int time = 0;
	
	Map<Transaction, [Near] TransactionData> transactionData = EmptyMap;
	
	// Maps transactions to the database locks they are currently owning. Usually, a lock
	// is acquired when it is needed (and not earlier) and released when the transaction
	// is completed.
	Map<Transaction, Set<DbLock>> dbLocks = EmptyMap;
	
	// Maps transactions to database locks which they are not allowed to acquire.
	// A transaction A is not allowed to acquire a lock if another already committed transaction B
	// has used this lock in order to perform an update and B was committed after A was started.
	// See also: The SAP HANA Database, 6.5.2 "Write Conflicts and Snapshot Isolation" (p. 52)
	Map<Transaction, Set<DbLock>> forbiddenDbLocks = EmptyMap;
	
	// Lock objects for currently hold database locks
	Map<DbLock, [Near] Lock> dbLockObjects = EmptyMap;
	
	// The dbLockObjectsLock synchronizes accesses to dbLockObjects and forbiddenDbLocks.
	[Near] Lock dbLockObjectsLock;
	
	// Lock for the database value
	[Near] Lock databaseLock;
	
	// set of listeners which will be called when tree operators are executed
	Set<[Near] DatabaseExecutionListener> listeners = EmptySet;
	
	// When a database lock is not obtained after this amount of time units, then an error is produced
	// in order to avoid deadlocks. A negative value means no deadlock protection.
	Int deadlockTime = 5;
	
	// Helper objects for calling listeners
	BeforeUnaryRelationalOperatorCaller beforeUnaryRelationalOperatorCaller;
	AfterUnaryRelationalOperatorCaller afterUnaryRelationalOperatorCaller;
	BeforeBinaryRelationalOperatorCaller beforeBinaryRelationalOperatorCaller;
	AfterBinaryRelationalOperatorCaller afterBinaryRelationalOperatorCaller;
	AfterRelationLoadingCaller afterRelationLoadingCaller;
	AfterCommitCaller afterCommitCaller;
	BeforeDbModificationOperatorCaller beforeDbModificationOperatorCaller;
	AfterDbModificationOperatorCaller afterDbModificationOperatorCaller;
	DatabaseExecutionListenerCaller beforeTransactionLockReleaseCaller;
	
	{
		this.initialize();
		beforeUnaryRelationalOperatorCaller = 
			new local BeforeUnaryRelationalOperatorCaller();
		afterUnaryRelationalOperatorCaller = 
			new local AfterUnaryRelationalOperatorCaller();
		beforeBinaryRelationalOperatorCaller = 
			new local BeforeBinaryRelationalOperatorCaller();
		afterBinaryRelationalOperatorCaller = 
			new local AfterBinaryRelationalOperatorCaller();
		afterRelationLoadingCaller =
			new local AfterRelationLoadingCaller();
		afterCommitCaller = new local AfterCommitCaller();
		beforeDbModificationOperatorCaller =
			new local BeforeDbModificationOperatorCaller();
		afterDbModificationOperatorCaller =
			new local AfterDbModificationOperatorCaller();
		beforeTransactionLockReleaseCaller =
			new local BeforeTransactionLockReleaseCaller();
	}
	
	[Atomic] Unit initialize() {
		scheme = Pair(convertExtendedRelationSchemesToTransactional(fst(scheme)), snd(scheme));
		database = createRelationsForSchemes(fst(scheme));
		dbLockObjectsLock = new local Lock();
		databaseLock = new local Lock();
	}

	MaybeEx<Relation> executeTree(ExecutionTree tree) {
		MaybeEx<Pair<Relation, ListenerArgumentMap>> result = this.executeTreeIntern(tree, database);
		return case result {
				JustEx(Pair(relation, _)) => JustEx(relation);
				error => forwardError(error, "executeTree");
			};
	}
	
	MaybeEx<Pair<Relation, ListenerArgumentMap>> executeTreeIntern(
			ExecutionTree tree, DatabaseValue dbState) {
		MaybeEx<Pair<Relation, ListenerArgumentMap>> result =
			Error("executeTreeIntern", "Cannot process execution tree of type \"" + executionTreeToString(tree) + "\".");
		if (isUnaryExecutionNode(tree)) {
			result = this.executeTreeIntern(getUnaryNodeChildTree(tree), dbState);
			if (isJustEx(result)) {
				UnaryRelationalOperator operator = getUnaryRelationalOperator(tree);
				Relation relation = fst(fromJustEx(result));
				beforeUnaryRelationalOperatorCaller.setArguments(operator, relation);
				MaybeEx<ListenerArgumentMap> listenerOpinion =
					this.callListeners(
						beforeUnaryRelationalOperatorCaller,
						listenerArgumentMapToArgumentsMap(snd(fromJustEx(result))));
				if (isJustEx(listenerOpinion)) {
					MaybeEx<Relation> resultRelation = executeUnaryRelationalOperator(operator, relation);
					afterUnaryRelationalOperatorCaller.setArguments(operator, relation, resultRelation);
					listenerOpinion = this.callListeners(
						afterUnaryRelationalOperatorCaller,
						listenerArgumentMapToArgumentsMap(fromJustEx(listenerOpinion)));
					if (isJustEx(listenerOpinion))
						result = if isJustEx(resultRelation)
							then JustEx(Pair(fromJustEx(resultRelation), fromJustEx(listenerOpinion)))
							else forwardError(resultRelation, "executeTreeIntern");
				}
				if (~isJustEx(listenerOpinion))
					result = forwardError(listenerOpinion, "executeTreeIntern");
			}
		} else if (isBinaryExecutionNode(tree)) {
			Pair<ExecutionTree, ExecutionTree> childTrees = getBinaryNodeChildTrees(tree);
			Fut<MaybeEx<Pair<Relation, ListenerArgumentMap>>> relationFut1 =
				this!executeTreeIntern(fst(childTrees), dbState);
			Fut<MaybeEx<Pair<Relation, ListenerArgumentMap>>> relationFut2 =
				this!executeTreeIntern(snd(childTrees), dbState);
			await relationFut1?;
			result = relationFut1.get;
			if (isJustEx(result)) {
				MaybeEx<Pair<Relation, ListenerArgumentMap>> result1 = result;
				await relationFut2?;
				result = relationFut2.get;
				if (isJustEx(result)) {
					BinaryRelationalOperator operator = getBinaryRelationalOperator(tree);
					Relation relation1 = fst(fromJustEx(result1));
					Relation relation2 = fst(fromJustEx(result));
					beforeBinaryRelationalOperatorCaller.setArguments(
							operator, relation1, relation2);
					MaybeEx<ListenerArgumentMap> listenerOpinion =
						this.callListeners(
							beforeBinaryRelationalOperatorCaller,
							prependToListenerArgumentsMap(
								snd(fromJustEx(result1)),
								listenerArgumentMapToArgumentsMap(snd(fromJustEx(result)))));
					if (isJustEx(listenerOpinion)) {
						MaybeEx<Relation> resultRelation = executeBinaryRelationalOperator(
							getBinaryRelationalOperator(tree),
							relation1,
							relation2);
						afterBinaryRelationalOperatorCaller.setArguments(
							operator, relation1, relation2, resultRelation);
						listenerOpinion = this.callListeners(
							afterBinaryRelationalOperatorCaller,
							listenerArgumentMapToArgumentsMap(fromJustEx(listenerOpinion)));
						if (isJustEx(listenerOpinion))
							result = case resultRelation {
									JustEx(relation) =>
										JustEx(Pair(relation, fromJustEx(listenerOpinion)));
									error => forwardError(error, "executeTreeIntern");
								};
					}
					if (~isJustEx(listenerOpinion))
						result = forwardError(listenerOpinion, "executeTreeIntern");
				}
			}
		} else if (isRelationLeafNode(tree)) {
			MaybeEx<Relation> resultRelation = getRelationForLeaf(tree, dbState);
			if (isJustEx(resultRelation)) {
				afterRelationLoadingCaller.setArguments(
					fromJustEx(resultRelation));
				MaybeEx<ListenerArgumentMap> listenerOpinion =
					this.callListeners(afterRelationLoadingCaller, EmptyMap);
				result = case listenerOpinion {
					JustEx(opinions) =>
						case resultRelation {
							JustEx(relation) => JustEx(Pair(relation, opinions));
							error => forwardError(error, "executeTreeIntern");
						};
					error => forwardError(error, "executeTreeIntern");
				};
			}
		}
		return result;
	}
	
	MaybeEx<Map<DatabaseExecutionListener, DatabaseExecutionListenerArgument>> callListeners(
			DatabaseExecutionListenerCaller caller,
			ListenerArgumentsMap args) {
		Map<DatabaseExecutionListener, DatabaseExecutionListenerArgument> result = EmptyMap;
		MaybeEx<DatabaseExecutionListenerArgument> singleResult = Error("", "");
		Bool error = False;
		Set<DatabaseExecutionListener> listeners = this.listeners;
		while (hasNext(listeners) && ~error) {
			Pair<Set<DatabaseExecutionListener>, DatabaseExecutionListener> iterator = next(listeners);
			DatabaseExecutionListener listener = snd(iterator);
			singleResult = caller.callListener(
				listener,
				lookupDefault(args, listener, Nil));
			if (isJustEx(singleResult))
				result = put(result, listener, fromJustEx(singleResult));
			else
				error = True;
			listeners = fst(iterator);
		}
		return if error then forwardError(singleResult, "callListeners") else JustEx(result);
	}
	
	// Execute the modification in a transaction. This causes the method to block if necessary.
	MaybeEx<Unit> modify(DbModificationOperator operator) {
		Transaction transaction = this.beginTransaction();
		MaybeEx<Unit> result = this.modifyInTransaction(operator, transaction);
		if (isJustEx(result))
			this.commitTransaction(transaction);
		else
			this.abortTransaction(transaction);
		return result;
	}
	
	// Returns Error if some operation is invalid.
	MaybeEx<DatabaseValue> modifyIntern(RelationalModificationOperator operator, String relationName,
			DatabaseValue baseState) {
		return executeDbModificationOperatorSafe(
			RelationalModification(relationName, operator),
			baseState,
			fst(scheme));
	}

	Transaction beginTransaction() {
		return this.beginTransactionFailFast(False);
	}

	// failFast: see ConsTransaction
	Transaction beginTransactionFailFast(Bool failFast) {
		return this.beginTransactionFailFastIntern(failFast);
	}
	
	[Atomic] Transaction beginTransactionFailFastIntern(Bool failFast) {
		Transaction transaction = TransactionCons(this, time, failFast);
		time = time + 1;
		TransactionData trxData = new local TransactionData(database);
		transactionData = put(transactionData, transaction, trxData);
		return transaction;
	}
	
	MaybeEx<Unit> commitTransaction(Transaction transaction) {
		MaybeEx<Unit> result = Error("modifyInTransaction", "The transaction is not active.");
		Maybe<TransactionData> trxDataMaybe = this.getTransactionData(transaction);
		if (isJust(trxDataMaybe)) {
			TransactionData trxData = fromJust(trxDataMaybe);
			Lock lock = trxData.getLock();
			lock.acquire();
			
			// Transaction might have been completed during waiting for the lock:
			trxDataMaybe = this.getTransactionData(transaction);
			if (isJust(trxDataMaybe)) {
				List<DbConstantModificationOperator> operators = trxData.getOperations();
				databaseLock.acquire();
				MaybeEx<DatabaseValue> newDbState =
					executeDbConstantModificationOperatorsSafe(operators, database, fst(scheme));
				dbLockObjectsLock.acquire();
				Bool success = isJustEx(newDbState);
				if (success) {
					database = fromJustEx(newDbState);
					result = JustEx(Unit);
					
					// Save locks which may not be used by currently active transactions any more:
					Set<DbLock> usedLocks = lookupDefault(dbLocks, transaction, EmptySet);
					if (hasNext(usedLocks)) {
						Set<Transaction> activeTransactions = keys(transactionData);
						while (hasNext(activeTransactions)) {
							Pair<Set<Transaction>, Transaction> nextTransaction = next(activeTransactions);
							Transaction curTransaction = snd(nextTransaction);
							Set<DbLock> oldForbiddenLocks =
								lookupDefault(forbiddenDbLocks, curTransaction, EmptySet);
							forbiddenDbLocks = put(
								forbiddenDbLocks,
								curTransaction,
								ABS.StdLib.union(oldForbiddenLocks, usedLocks));
							activeTransactions = fst(nextTransaction);
						}
					}
				} else
					result = forwardError(newDbState, "commitTransaction");
				this.completeTransaction(transaction);
				dbLockObjectsLock.release();
				databaseLock.release();
				afterCommitCaller.setArguments(success);
				this.callListeners(afterCommitCaller, EmptyMap);
			}
			this!releaseTransactionLock(lock);
		}
		return result;
	}
	
	Unit abortTransaction(Transaction transaction) {
		Maybe<TransactionData> trxDataMaybe = this.getTransactionData(transaction);
		if (isJust(trxDataMaybe)) {
			TransactionData trxData = fromJust(trxDataMaybe);
			Lock lock = trxData.getLock();
			lock.acquire();
			
			// Transaction might have been completed during waiting for the lock:
			trxDataMaybe = this.getTransactionData(transaction);
			if (isJust(trxDataMaybe)) {
				dbLockObjectsLock.acquire();
				this.completeTransaction(transaction);
				dbLockObjectsLock.release();
			}
			this!releaseTransactionLock(lock);
		}
	}
	
	// The executing context must have the lock dbLockObjectsLock and the transaction lock.
	[Atomic] Unit completeTransaction(Transaction transaction) {
		transactionData = removeKey(transactionData, transaction);
		forbiddenDbLocks = removeKey(forbiddenDbLocks, transaction);
		Set<DbLock> usedLocks = lookupDefault(dbLocks, transaction, EmptySet);
		Set<DbLock> iterator = usedLocks;
		while (hasNext(iterator)) {
			Pair<Set<DbLock>, DbLock> nextLock = next(iterator);
			DbLock curDbLock = snd(nextLock);
			Lock dbLockObject = fromJust(lookup(dbLockObjects, curDbLock));
			dbLockObject.release();
			dbLockObjects = removeKey(dbLockObjects, curDbLock);
			iterator = fst(nextLock);
		}
		dbLocks = removeKey(dbLocks, transaction);
	}
	
	MaybeEx<Relation> executeTreeInTransaction(ExecutionTree tree, Transaction transaction) {
		Maybe<TransactionData> trxDataMaybe = this.getTransactionData(transaction);
		MaybeEx<Relation> result = Error("executeTreeInTransaction", "No state available for transaction. Have you called beginTransaction?");
		if (isJust(trxDataMaybe)) {
			DatabaseValue dbState = fromJust(trxDataMaybe).getSnapshot();
			MaybeEx<Pair<Relation, ListenerArgumentMap>> internResult = this.executeTreeIntern(tree, dbState);
			result = case internResult {
					JustEx(Pair(relation, _)) => JustEx(relation);
					error => forwardError(error, "executeTreeInTransaction");
				};
		}
		return result;
	}
	
	MaybeEx<Unit> modifyInTransaction(DbModificationOperator operator, Transaction transaction) {
		MaybeEx<Unit> result = JustEx(Unit);
		Maybe<TransactionData> trxDataMaybe = this.getTransactionData(transaction);
		if (isJust(trxDataMaybe)) {
			TransactionData trxData = fromJust(trxDataMaybe);
			Lock lock = trxData.getLock();
			// Wait until other operations of same transaction are finished:
			lock.acquire();
			
			DatabaseValue dbState = trxData.getSnapshot();
			
			// Inform listeners about the operation:
			beforeDbModificationOperatorCaller.setArguments(operator, dbState);
			MaybeEx<ListenerArgumentMap> listenerOpinion = this.callListeners(
				beforeDbModificationOperatorCaller, EmptyMap);
			if (isJustEx(listenerOpinion)) {
				// Generate constant modification operators for the operation based on the currently valid DB snapshot:
				List<DbConstantModificationOperator> modifications = trxData.getOperations();
				Int nextTupleId = trxData.getNextTupleId();
				MaybeEx<Pair<List<DbConstantModificationOperator>, Int>> newModifications =
					generateDbConstantModificationOperators(
						operator,
						dbState,
						Pair(transactionId(transaction), nextTupleId));
				if (isJustEx(newModifications)) {
					// Acquire locks needed to perform the operation:
					Pair<List<DbConstantModificationOperator>, Int> modificationsResult =
						fromJustEx(newModifications);
					Set<DbLock> newAcquiredLocks = EmptySet;
					List<DbConstantModificationOperator> operators = fst(modificationsResult);
					List<DbConstantModificationOperator> operatorIterator = operators;
					Bool dbLocksAcquired = True;
					while (~isEmpty(operatorIterator) && dbLocksAcquired) {
						Set<DbLock> operationDbLocks = generateDbLocksForOperation(head(operatorIterator));
						while (hasNext(operationDbLocks) && dbLocksAcquired) {
							Pair<Set<DbLock>, DbLock> nextDbLock = next(operationDbLocks);
							DbLock curDbLock = snd(nextDbLock);
							if (~contains(lookupDefault(dbLocks, transaction, EmptySet), curDbLock)) {
								dbLocksAcquired = this.acquireDbLock(curDbLock, transaction, failFast(transaction));
								if (dbLocksAcquired)
									newAcquiredLocks = Insert(curDbLock, newAcquiredLocks);
								else
									result = Error("modifyInTransaction", "Could not acquire lock " + dbLockToString(curDbLock) + ".");
							}
							operationDbLocks = fst(nextDbLock);
						}
						operatorIterator = tail(operatorIterator);
					}
					if (dbLocksAcquired) {
						// Apply the operation to the currently valid DB snapshot and save the new transaction data:
						MaybeEx<DatabaseValue> newState =
							executeDbConstantModificationOperatorsSafe(operators, dbState, fst(scheme));
						if (isJustEx(newState)) {
							trxData.setSnapshot(fromJustEx(newState));
							trxData.setOperations(concatenate(modifications, operators));
							trxData.setNextTupleId(snd(modificationsResult));
							afterDbModificationOperatorCaller.setArguments(
								operator, dbState, fromJustEx(newState));
							this.callListeners(
								afterDbModificationOperatorCaller,
								listenerArgumentMapToArgumentsMap(fromJustEx(listenerOpinion)));
						} else {
							this.releaseLocks(newAcquiredLocks, transaction);
							result = forwardError(newState, "modifyInTransaction");
						}
					} else
						this.releaseLocks(newAcquiredLocks, transaction);
				} else
					result = forwardError(newModifications, "modifyInTransaction");
			} else
				result = forwardError(listenerOpinion, "modifyInTransaction");
			this!releaseTransactionLock(lock);
		} else
			result = Error("modifyInTransaction", "The transaction is not active.");
		return result;
	}
	
	// This method should be called asynchronously because listeners might delay the lock release
	// but the calling method might want to return fast if not depending on the fact that the lock
	// is released.
	Unit releaseTransactionLock(Lock lock) {
		this.callListeners(beforeTransactionLockReleaseCaller, EmptyMap);
		lock.release();
	}

	// If a lock is free and not forbidden for the transaction, it is acquired and True is returned.
	// If a lock is forbidden for the transaction, False is returned.
	// If a lock is not free and not forbidden, the method 
	//  a) failFast = False: blocks until the lock is free and then checks again
	//  b) failFast = True: returns False.
	// The calling context must have the lock for the transaction.
	Bool acquireDbLock(DbLock lock, Transaction transaction, Bool failFast) {
		Set<DbLock> trxDbLocks = lookupDefault(dbLocks, transaction, EmptySet);
		Bool success = contains(trxDbLocks, lock);
		if (~success) {
			dbLockObjectsLock.acquire();
			success = this.isLockForbidden(lock, transaction);
			success = ~success;
			if (success) {
				Lock dbLockObject = null;
				Maybe<Lock> dbLockObjectMaybe = lookup(dbLockObjects, lock);
				if (isJust(dbLockObjectMaybe))
					dbLockObject = fromJust(dbLockObjectMaybe);
				else {
					dbLockObject = new local Lock();
					dbLockObjects = put(dbLockObjects, lock, dbLockObject);
				}
				dbLockObjectsLock.release();
				if (failFast)
					success = dbLockObject.tryAcquire();
				else if (deadlockTime < 0) {
					dbLockObject.acquire();
					success = True;
				} else
					success = dbLockObject.acquireInTime(deadlockTime);
				if (success) {
					// Lock might now be forbidden:
					success = this.isLockForbidden(lock, transaction);
					success = ~success;
					if (success)
						dbLocks = put(dbLocks, transaction, insertElement(trxDbLocks, lock));
					else
						dbLockObject.release();
				}
			} else
				dbLockObjectsLock.release();
		}
		return success;
	}
	
	// The executing context must own the transaction lock.
	Unit releaseLocks(Set<DbLock> dbLocksToRelease, Transaction transaction) {
		Set<DbLock> iterator = dbLocksToRelease;
		dbLockObjectsLock.acquire();
		while (hasNext(iterator)) {
			Pair<Set<DbLock>, DbLock> nextLock = next(iterator);
			DbLock curDbLock = snd(nextLock);
			Lock dbLockObject = fromJust(lookup(dbLockObjects, curDbLock));
			dbLockObject.release();
			dbLockObjects = removeKey(dbLockObjects, curDbLock);
			iterator = fst(nextLock);
		}
		dbLockObjectsLock.release();
		Set<DbLock> usedLocks = lookupDefault(dbLocks, transaction, EmptySet);
		dbLocks = put(dbLocks, transaction, setDifference(usedLocks, dbLocksToRelease));
	}
	
	Bool isLockForbidden(DbLock lock, Transaction transaction) {
		return contains(lookupDefault(forbiddenDbLocks, transaction, EmptySet), lock);
	}

	Maybe<TransactionData> getTransactionData(Transaction transaction) {
		return lookup(transactionData, transaction);
	}
	
	[Atomic] Unit addListener(DatabaseExecutionListener listener) {
		listeners = insertElement(listeners, listener);
	}
	
	[Atomic] Unit removeListener(DatabaseExecutionListener listener) {
		listeners = remove(listeners, listener);
	}

}


// Network transmission and connections

// Data which may be transmitted from and to a database
data DatabaseInterfaceDatum =
	DbRelationDatum(Relation dbRelationDatum) |
	DbScalarDatum(AttributeValue dbScalarDatum) |
	DbExecutionTreeDatum(ExecutionTree dbExecutionTreeDatum) |
	DbModificationOperatorDatum(DbModificationOperator dbModificationOperatorDatum) |
	DbMaybeDatum(Maybe<DatabaseInterfaceDatum> dbMaybeDatum) |
	DbMaybeExDatum(MaybeEx<DatabaseInterfaceDatum> dbMaybeExDatum);

def Bool isDbRelationDatum(DatabaseInterfaceDatum datum) =
	case datum {
		DbRelationDatum(_) => True;
		_ => False;
	};

def Bool isDbScalarDatum(DatabaseInterfaceDatum datum) =
	case datum {
		DbScalarDatum(_) => True;
		_ => False;
	};

def Bool isDbExecutionTreeDatum(DatabaseInterfaceDatum datum) =
	case datum {
		DbExecutionTreeDatum(_) => True;
		_ => False;
	};

def Bool isDbModificationOperatorDatum(DatabaseInterfaceDatum datum) =
	case datum {
		DbModificationOperatorDatum(_) => True;
		_ => False;
	};

def Bool isDbMaybeDatum(DatabaseInterfaceDatum datum) =
	case datum {
		DbMaybeDatum(_) => True;
		_ => False;
	};

def Bool isDbMaybeExDatum(DatabaseInterfaceDatum datum) =
	case datum {
		DbMaybeExDatum(_) => True;
		_ => False;
	};

// Calculates the times that are needed to transmit database data via a network.
// The network delay is not considered.
interface TransmissionTimeCalculator {
	Int calcTimeForInterfaceDatum(DatabaseInterfaceDatum datum);
}

// TransmissionTimeCalculator which assigns transmission cost 0 to every transmitted datum.
class IdealTransmissionTimeCalculator implements TransmissionTimeCalculator {
	
	Int calcTimeForInterfaceDatum(DatabaseInterfaceDatum datum) {
		return 0;
	}
	
}

// DB Connection
interface DatabaseConnection extends RelationalTransactionalDatabase {
	RelationalTransactionalDatabase getWrappee();
	Unit transmissionDelay(DatabaseInterfaceDatum datum);
	Unit propagationDelay();
}

// Wraps a database and, in each call to it, includes the given network delay. The propagationDelay
// value is one-way, i.e., it occurs twice when calling the database and receiving the response.
class DatabaseConnection([Final] RelationalTransactionalDatabase wrappee,
		Int propagationDelay, TransmissionTimeCalculator transmissionTimeCalculator)
		implements DatabaseConnection {
	
	RelationalTransactionalDatabase getWrappee() {
		return wrappee;
	}
	
	Unit transmitForTime(Int time) {
		await duration(time, time);
	}
	
	Unit propagationDelay() {
		await duration(propagationDelay, propagationDelay);
	}
		
	MaybeEx<Relation> executeTree(ExecutionTree tree) {
		this.transmissionDelay(DbExecutionTreeDatum(tree));
		this.propagationDelay();
		MaybeEx<Relation> result = wrappee.executeTree(tree);
		if (isJustEx(result))
			this.transmissionDelay(DbRelationDatum(fromJustEx(result)));
		this.propagationDelay();
		return result;
	}
	
	MaybeEx<Unit> modify(DbModificationOperator operator) {
		this.transmissionDelay(DbModificationOperatorDatum(operator));
		this.propagationDelay();
		MaybeEx<Unit> result = wrappee.modify(operator);
		this.propagationDelay();
		return result;
	}
	
	[Atomic] Unit addListener(DatabaseExecutionListener listener) {
		// Not a database operation - no delay
		wrappee.addListener(listener);
	}
	
	[Atomic] Unit removeListener(DatabaseExecutionListener listener) {
		// Not a database operation - no delay
		wrappee.addListener(listener);
	}

	Transaction beginTransaction() {
		this.propagationDelay();
		Transaction tx = wrappee.beginTransaction();
		this.propagationDelay();
		return tx;
	}
	
	Transaction beginTransactionFailFast(Bool failFast) {
		this.propagationDelay();
		Transaction tx = wrappee.beginTransactionFailFast(failFast);
		this.propagationDelay();
		return tx;
	}
	
	MaybeEx<Unit> commitTransaction(Transaction transaction) {
		this.propagationDelay();
		MaybeEx<Unit> result = wrappee.commitTransaction(transaction);
		this.propagationDelay();
		return result;
	}
	
	Unit abortTransaction(Transaction transaction) {
		this.propagationDelay();
		wrappee.abortTransaction(transaction);
		// Need not to wait for an answer.
	}
	
	MaybeEx<Relation> executeTreeInTransaction(ExecutionTree tree, Transaction transaction) {
		this.transmissionDelay(DbExecutionTreeDatum(tree));
		this.propagationDelay();
		MaybeEx<Relation> result = wrappee.executeTreeInTransaction(tree, transaction);
		if (isJustEx(result))
			this.transmissionDelay(DbRelationDatum(fromJustEx(result)));
		this.propagationDelay();
		return result;
	}

	MaybeEx<Unit> modifyInTransaction(DbModificationOperator operator, Transaction transaction) {
		this.transmissionDelay(DbModificationOperatorDatum(operator));
		this.propagationDelay();
		MaybeEx<Unit> result = wrappee.modifyInTransaction(operator, transaction);
		this.propagationDelay();
		return result;
	}
	
	Unit transmissionDelay(DatabaseInterfaceDatum datum) {
		Int time = transmissionTimeCalculator.calcTimeForInterfaceDatum(datum);
		this.transmitForTime(time);
	}

}

// Annotations
// Statements containing sql expressions or the method they are contained in must be annotated with
// the transaction to be used.
type TX = Transaction;

// SQL expressions annotated with SqlAsync will produce a future instead of the direct return value.
// No annotation is equivalent to the annotation SqlSync.
// Also applicable to methods. SQL statements inherit the annotation from the containing method.
data SqlCallStyle = SqlSync | SqlAsync;

// [DatabaseConnection: conn] assigns a certain connection to an SQL expression or a method. All
// sql operations will then cause network delays according to the connection.

// Methods annotated with SqlProc and a database connection will include network delays only before
// and after the method execution, not between single sql statements. Such methods must only have
// return type and parameters of type DatabaseInterfaceDatum or Unit.
// SqlProc without a database connection annotation for the method does not have any effect.
data SqlProc = SqlProc;


// Empty modules:
module ABS.DB.RelationKnowledge;
module ABS.DB.RelationKnowledge.Structure;