/* This file was generated with JastAdd2 (http://jastadd.org) version 2.1.4 */
package abs.frontend.ast;

import java.io.PrintStream;
import beaver.Symbol;
import java.io.*;
import abs.frontend.ast.*;
import abs.backend.erlang.*;
import java.util.Iterator;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeInferrerExtension;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeVariable;
import abs.frontend.typechecker.locationtypes.LocationType;
import abs.backend.erlang.ErlUtil.Mask;
import org.apache.commons.io.output.WriterOutputStream;
import java.nio.charset.Charset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import abs.backend.java.*;
import abs.backend.java.codegeneration.*;
import abs.backend.java.lib.runtime.*;
import abs.backend.java.lib.expr.*;
import abs.backend.java.lib.types.*;
import abs.backend.java.codegeneration.dynamic.*;
import abs.backend.java.codegeneration.JavaCode;
import abs.backend.java.codegeneration.JavaCodeGenerationException;
import java.util.Set;
import java.util.TreeSet;
import abs.backend.maude.MaudeCompiler;
import abs.backend.maude.MaudeCompilerHelper;
import java.io.PrintWriter;
import abs.backend.prettyprint.*;
import abs.backend.prolog.*;
import static abs.backend.prolog.PrologBackend.fieldTransform;
import static abs.backend.prolog.PrologBackend.initialToUpperCase;
import static abs.backend.prolog.PrologBackend.varTransform;
import static abs.backend.prolog.PrologBackend.strTransform;
import static abs.backend.prolog.PrologBackend.quote;
import java.util.HashSet;
import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.analyser.*;
import abs.frontend.typechecker.*;
import java.util.Collections;
import java.util.Map;
import abs.common.*;
import abs.frontend.typechecker.Type;
import abs.frontend.typechecker.DataTypeType;
import abs.frontend.ast.InterfaceDecl;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.frontend.parser.*;
import abs.frontend.mtvl.ChocoSolver;
import choco.Choco;
import choco.kernel.model.constraints.Constraint;
import choco.kernel.model.variables.integer.IntegerVariable;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;
import abs.frontend.mtvl.Types;
import abs.frontend.parser.ParserError;
import java.util.*;
import java.util.regex.*;
import abs.frontend.tests.*;
import abs.frontend.treecopy.ParseTreeCopyHelper;
import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.TypeCheckerHelper;
import abs.frontend.typechecker.KindedName;
import abs.frontend.typechecker.ResolvedName;
import javax.annotation.CheckForNull;
import abs.frontend.typechecker.KindedName.Kind;
import java.util.Arrays;
import abs.frontend.typechecker.ext.*;
/**
 * @ast node
 * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/ast/ABS.ast:235
 * @production Call : {@link EffExp} ::= <span class="component">Callee:{@link PureExp}</span> <span class="component">&lt;Method:String&gt;</span> <span class="component">Param:{@link PureExp}*</span>;

 */
public abstract class Call extends EffExp implements Cloneable, HasActualParams {
  /**
   * @aspect GenerateMaude
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/maude/GenerateMaude.jadd:156
   */
  public int numberOfRandom(Set<String> visitedFunctions) {
        int result = 0;
        for (PureExp param : getParams()) {
            result += param.numberOfRandom(visitedFunctions);
        }
        return result;
    }
  /**
   * @aspect doPrettyPrinter
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prettyprint/PrettyPrinter.jadd:241
   */
  public void doPrettyPrint(PrintWriter stream, ABSFormatter formatter) {
        doPrettyPrintCallPrefix(stream, formatter);
        getCallee().doPrettyPrint(stream, formatter);
        doPrettyPrintCallType(stream, formatter);
        stream.print(getMethod().replaceAll("\\$", ""));
        stream.print("(");
        getParamList().doPrettyPrint(stream, formatter, ",");
        stream.print(")");
    }
  /**
   * @aspect doPrettyPrinter
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prettyprint/PrettyPrinter.jadd:251
   */
  abstract public void doPrettyPrintCallType(PrintWriter stream, ABSFormatter formatter);
  /**
   * @aspect doPrettyPrinter
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prettyprint/PrettyPrinter.jadd:253
   */
  abstract public void doPrettyPrintCallPrefix(PrintWriter stream, ABSFormatter formatter);
  /**
   * @aspect GenerateProlog
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prolog/GenerateProlog.jadd:870
   */
  public void generateProlog(PrintStream s,ReachabilityInformation reachInfo) {
  		//generates "syncCall(Callee,CalledInterfaces,MethodName,ArgumentsList,[LocationType])"
        // or "asyncCall(Callee,CalledInterfaces,MethodName,ArgumentsList,[LocationType])"

        if(this instanceof SyncCall)
            s.print("syncCall(");
        else
            s.print("asyncCall(");

        this.getCallee().generateProlog(s,reachInfo);
        s.print(",[");
        //we need to know which are the interfaces to whom the called method belongs
        generateInterfacesList(s,this.getCallee().getType());
        s.print("],"+quote(this.getMethod())+",[");
        List<?> arguments = (List<?>) getChild(1);
        int n = arguments.getNumChild();
        for (int i = 0; i < n; i++){
            arguments.getChild(i).generateProlog(s,reachInfo);
            if (i != n-1) s.print(",");
        }
        s.print("],[");
        LocationTypeInferrerExtension locationTypeSystem=(LocationTypeInferrerExtension)this.getModel().getTypeExt().getFirstRegisteredTypeExtension(LocationTypeInferrerExtension.class);
        if(locationTypeSystem!=null){
          LocationTypeVariable lv = LocationTypeInferrerExtension.getLV(this.getCallee().getType());
          LocationType tv=locationTypeSystem.getResults().get(lv);
          s.print("'"+tv.toString()+"'");
        }
        s.print("])");

    }
  /**
   * @aspect GenerateProlog
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prolog/GenerateProlog.jadd:902
   */
  private void generateInterfacesList(PrintStream s,Type type) {
        if(type.isUnionType()){
            UnionType unionType=(UnionType)type;
            Iterator<InterfaceType> it=unionType.getTypes().iterator();
            while(it.hasNext()){
                generateInterfacesList(s,it.next());
                if(it.hasNext())
                    s.print(",");
            }
        }else
            if(type.isInterfaceType()){
                s.print(quote(type.toString()));
            }else
                throw new PrologBackendException("the call "+this+" is done using the following illegal type "+type);
    }
  /**
   * @aspect collectReachableCode
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prolog/collectReachableCode.jadd:71
   */
  private void generateInterfacesList(Type type,ArrayList<InterfaceType> interfaces) {
        if(type.isUnionType()){
            UnionType unionType=(UnionType)type;
            Iterator<InterfaceType> it=unionType.getTypes().iterator();
            while(it.hasNext()){
                generateInterfacesList(it.next(),interfaces);

            }
        }else
            if(type.isInterfaceType()){
                interfaces.add((InterfaceType)type);
            }   
    }
  /**
   * @aspect collectReachableCode
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prolog/collectReachableCode.jadd:85
   */
  public void collectReachableCode(ReachabilityInformation reachInfo){

        if(this.getCallee() instanceof ThisExp){
            reachInfo.addReachability((ClassDecl)this.getContextDecl(),this.getMethodSig());
        }else{
            ArrayList<InterfaceType> interfaces=new ArrayList<InterfaceType>();
            generateInterfacesList(this.getCallee().getType(),interfaces);
            for(InterfaceType inter: interfaces){
                reachInfo.addReachability(inter,this.getMethodSig());
                reachInfo.addReachability(inter);
            }
        }
        super.collectReachableCode(reachInfo);
    }
  /**
   * @aspect MyDumpTree
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/MyDumpTree.jadd:184
   */
  protected void printInfo(PrintStream stream)
    {
    	stream.print(this.getMethod());
    }
  /**
   * @aspect ParseTreeCopy
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/treecopy/ParseTreeCopy.jadd:43
   */
  public Call parseTreeCopy() { return ParseTreeCopyHelper.parseTreeCopy(this); }
  /**
   * @aspect TypeChecker
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeChecker.jadd:719
   */
  public void refined_TypeChecker_Call_typeCheck(SemanticErrorList e) {
        Type t = getType();
        if (getCallee().getType().isNullType()) {
            e.add(new TypeError(this, ErrorMessage.NULL_NOT_HERE, ""));
            return;
        }
        getCallee().typeCheck(e);
        if (t.isUnknownType() || getMethodSig() == null) {
            e.add(new TypeError(this, ErrorMessage.METHOD_NOT_FOUND, getMethod()));
        } else {
            typeCheckEqualParams(e,getMethodSig());
        }
    }
  /**
   * @aspect Typing
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/Typing.jrag:395
   */
  public java.util.List<Type> getTypesFromExp() { return TypeCheckerHelper.getTypes(getParams()); }
  /**
   * @aspect Typing
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/Typing.jrag:410
   */
  public void typeCheckEqualParams(SemanticErrorList l, HasParams params) {
        TypeCheckerHelper.typeCheckEqual(l, this, params.getTypes());
    }
  /**
   * @aspect Typing
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/Typing.jrag:413
   */
  public Map<TypeParameter, Type> getTypeParamBinding(ASTNode<?> node, HasTypes params) {
        return params.getTypeParamBinding(node, getTypesFromExp());
    }
  /**
   * @declaredat ASTNode:1
   */
  public Call() {
    super();
  }
  /**
   * Initializes the child array to the correct size.
   * Initializes List and Opt nta children.
   * @apilevel internal
   * @ast method
   * @declaredat ASTNode:10
   */
  public void init$Children() {
    children = new ASTNode[2];
    setChild(new List(), 1);
  }
  /**
   * @declaredat ASTNode:14
   */
  public Call(PureExp p0, String p1, List<PureExp> p2) {
    setChild(p0, 0);
    setMethod(p1);
    setChild(p2, 1);
  }
  /**
   * @declaredat ASTNode:19
   */
  public Call(PureExp p0, beaver.Symbol p1, List<PureExp> p2) {
    setChild(p0, 0);
    setMethod(p1);
    setChild(p2, 1);
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:27
   */
  protected int numChildren() {
    return 2;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:33
   */
  public boolean mayHaveRewrite() {
    return false;
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:39
   */
  public void flushCache() {
    super.flushCache();
    getFreeVars_visited = -1;
    getFreeVars_computed = false;
    getFreeVars_value = null;
    isAsync_visited = -1;
    getCallType_visited = -1;
    getCallType_computed = false;
    getCallType_value = null;
    getMethodSig_visited = -1;
    getMethodSig_computed = false;
    getMethodSig_value = null;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:55
   */
  public void flushCollectionCache() {
    super.flushCollectionCache();
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:61
   */
  public Call clone() throws CloneNotSupportedException {
    Call node = (Call) super.clone();
    node.getFreeVars_visited = -1;
    node.getFreeVars_computed = false;
    node.getFreeVars_value = null;
    node.isAsync_visited = -1;
    node.getCallType_visited = -1;
    node.getCallType_computed = false;
    node.getCallType_value = null;
    node.getMethodSig_visited = -1;
    node.getMethodSig_computed = false;
    node.getMethodSig_value = null;
    node.in$Circle(false);
    node.is$Final(false);
    return node;
  }
  /**
   * Replaces the Callee child.
   * @param node The new node to replace the Callee child.
   * @apilevel high-level
   */
  public void setCallee(PureExp node) {
    setChild(node, 0);
  }
  /**
   * Retrieves the Callee child.
   * @return The current node used as the Callee child.
   * @apilevel high-level
   */
  public PureExp getCallee() {
    return (PureExp) getChild(0);
  }
  /**
   * Retrieves the Callee child.
   * <p><em>This method does not invoke AST transformations.</em></p>
   * @return The current node used as the Callee child.
   * @apilevel low-level
   */
  public PureExp getCalleeNoTransform() {
    return (PureExp) getChildNoTransform(0);
  }
  /**
   * Replaces the lexeme Method.
   * @param value The new value for the lexeme Method.
   * @apilevel high-level
   */
  public void setMethod(String value) {
    tokenString_Method = value;
  }
  /**
   * @apilevel internal
   */
  protected String tokenString_Method;
  /**
   */
  public int Methodstart;
  /**
   */
  public int Methodend;
  /**
   * JastAdd-internal setter for lexeme Method using the Beaver parser.
   * @param symbol Symbol containing the new value for the lexeme Method
   * @apilevel internal
   */
  public void setMethod(beaver.Symbol symbol) {
    if(symbol.value != null && !(symbol.value instanceof String))
    throw new UnsupportedOperationException("setMethod is only valid for String lexemes");
    tokenString_Method = (String)symbol.value;
    Methodstart = symbol.getStart();
    Methodend = symbol.getEnd();
  }
  /**
   * Retrieves the value for the lexeme Method.
   * @return The value for the lexeme Method.
   * @apilevel high-level
   */
  public String getMethod() {
    return tokenString_Method != null ? tokenString_Method : "";
  }
  /**
   * Replaces the Param list.
   * @param list The new list node to be used as the Param list.
   * @apilevel high-level
   */
  public void setParamList(List<PureExp> list) {
    setChild(list, 1);
  }
  /**
   * Retrieves the number of children in the Param list.
   * @return Number of children in the Param list.
   * @apilevel high-level
   */
  public int getNumParam() {
    return getParamList().getNumChild();
  }
  /**
   * Retrieves the number of children in the Param list.
   * Calling this method will not trigger rewrites.
   * @return Number of children in the Param list.
   * @apilevel low-level
   */
  public int getNumParamNoTransform() {
    return getParamListNoTransform().getNumChildNoTransform();
  }
  /**
   * Retrieves the element at index {@code i} in the Param list.
   * @param i Index of the element to return.
   * @return The element at position {@code i} in the Param list.
   * @apilevel high-level
   */
  public PureExp getParam(int i) {
    return (PureExp) getParamList().getChild(i);
  }
  /**
   * Check whether the Param list has any children.
   * @return {@code true} if it has at least one child, {@code false} otherwise.
   * @apilevel high-level
   */
  public boolean hasParam() {
    return getParamList().getNumChild() != 0;
  }
  /**
   * Append an element to the Param list.
   * @param node The element to append to the Param list.
   * @apilevel high-level
   */
  public void addParam(PureExp node) {
    List<PureExp> list = (parent == null || state == null) ? getParamListNoTransform() : getParamList();
    list.addChild(node);
  }
  /**
   * @apilevel low-level
   */
  public void addParamNoTransform(PureExp node) {
    List<PureExp> list = getParamListNoTransform();
    list.addChild(node);
  }
  /**
   * Replaces the Param list element at index {@code i} with the new node {@code node}.
   * @param node The new node to replace the old list element.
   * @param i The list index of the node to be replaced.
   * @apilevel high-level
   */
  public void setParam(PureExp node, int i) {
    List<PureExp> list = getParamList();
    list.setChild(node, i);
  }
  /**
   * Retrieves the Param list.
   * @return The node representing the Param list.
   * @apilevel high-level
   */
  public List<PureExp> getParamList() {
    List<PureExp> list = (List<PureExp>) getChild(1);
    list.getNumChild();
    return list;
  }
  /**
   * Retrieves the Param list.
   * <p><em>This method does not invoke AST transformations.</em></p>
   * @return The node representing the Param list.
   * @apilevel low-level
   */
  public List<PureExp> getParamListNoTransform() {
    return (List<PureExp>) getChildNoTransform(1);
  }
  /**
   * Retrieves the Param list.
   * @return The node representing the Param list.
   * @apilevel high-level
   */
  public List<PureExp> getParams() {
    return getParamList();
  }
  /**
   * Retrieves the Param list.
   * <p><em>This method does not invoke AST transformations.</em></p>
   * @return The node representing the Param list.
   * @apilevel low-level
   */
  public List<PureExp> getParamsNoTransform() {
    return getParamListNoTransform();
  }
  /**
   * @aspect TypeCheckerExtension
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/ext/TypeCheckerExtension.jadd:197
   */
    public void typeCheck(SemanticErrorList s) {
        int size = s.size();
        refined_TypeChecker_Call_typeCheck(s);
        if (s.size() > size) return;
        getModel().getTypeExt().checkMethodCall(this);
        if (getMethodSig() != null) {
           getModel().getTypeExt().checkAssignable(getCallee().getType(),getMethodSig(),this);
        }
    }
  /**
   * @apilevel internal
   */
  protected int getFreeVars_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getFreeVars_computed = false;
  /**
   * @apilevel internal
   */
  protected Set<String> getFreeVars_value;
  /**
   * @attribute syn
   * @aspect VarUsage
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/FreeVars.jrag:66
   */
  public Set<String> getFreeVars() {
    if(getFreeVars_computed) {
      return getFreeVars_value;
    }
    ASTNode$State state = state();
    if (getFreeVars_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getFreeVars in class: org.jastadd.ast.AST.SynDecl");
    }
    getFreeVars_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getFreeVars_value = getFreeVars_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getFreeVars_computed = true;
    } else {
    }

    getFreeVars_visited = -1;
    return getFreeVars_value;
  }
  /**
   * @apilevel internal
   */
  private Set<String> getFreeVars_compute() {
  		HashSet<String> res = new HashSet<String>();
  		res.addAll(getCallee().getFreeVars());
  		for (PureExp e : getParams()) {
  		   res.addAll(e.getFreeVars());
  		}
  		return res;
  	}
  /**
   * @apilevel internal
   */
  protected int isAsync_visited = -1;
  /**
   * TODO Someone should really document why ALSO AsyncCall.isAsync() = false;
   * @attribute syn
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:416
   */
  public boolean isAsync() {
    ASTNode$State state = state();
    if (isAsync_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: isAsync in class: org.jastadd.ast.AST.SynDecl");
    }
    isAsync_visited = state().boundariesCrossed;
    try {  return false;  }
    finally {
      isAsync_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getCallType_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getCallType_computed = false;
  /**
   * @apilevel internal
   */
  protected Type getCallType_value;
  /**
   * @attribute syn
   * @aspect Typing
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/Typing.jrag:145
   */
  public Type getCallType() {
    if(getCallType_computed) {
      return getCallType_value;
    }
    ASTNode$State state = state();
    if (getCallType_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getCallType in class: org.jastadd.ast.AST.SynDecl");
    }
    getCallType_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getCallType_value = getCallType_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getCallType_computed = true;
    } else {
    }

    getCallType_visited = -1;
    return getCallType_value;
  }
  /**
   * @apilevel internal
   */
  private Type getCallType_compute() {
     	 MethodSig s = getMethodSig();
     	 if (s == null)
     		 return UnknownType.INSTANCE;
     	 return s.getType();
      }
  /**
   * @apilevel internal
   */
  protected int getMethodSig_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getMethodSig_computed = false;
  /**
   * @apilevel internal
   */
  protected MethodSig getMethodSig_value;
  /**
   * @attribute syn
   * @aspect Typing
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/Typing.jrag:152
   */
  public MethodSig getMethodSig() {
    if(getMethodSig_computed) {
      return getMethodSig_value;
    }
    ASTNode$State state = state();
    if (getMethodSig_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getMethodSig in class: org.jastadd.ast.AST.SynDecl");
    }
    getMethodSig_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getMethodSig_value = getMethodSig_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getMethodSig_computed = true;
    } else {
    }

    getMethodSig_visited = -1;
    return getMethodSig_value;
  }
  /**
   * @apilevel internal
   */
  private MethodSig getMethodSig_compute() {
  		Type t = getCallee().getType();
  		MethodSig s = t.lookupMethod(getMethod());
  		return s;
      }
  /**
   * @apilevel internal
   */
  public ASTNode rewriteTo() {    return super.rewriteTo();
  }}
