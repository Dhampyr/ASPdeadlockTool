/*
 * @Author Vincenzo Mastandrea
 * Grammar definition for ASP
 */
 
grammar ASPgrammar;
 
@header{
import asp.models.*;
import java.util.HashMap;
import java.util.LinkedList; 
}
program returns [Program prog]
				@init{HashMap<String, Class> classMap = new HashMap<>();
					  StmtBlock main = new StmtBlock();}
				:   (classDec {classMap.add($classDec.classObj.getClassName(),$classDec.classObj)})* 
				    (body {main.setVarDec($body.varDec);
				    	   main.setStmts($body.stmts);}) 
				    {$prog = new Program(classMap, main)};

classDec returns [Class classObj]
				@init{LinkedList<TypeBase> fields = new LinkedList<>;
					  LinkedList<TypeBase> parameters = new LinkedList<>; 
					  HashMap<String, Method> methods = new LinkedList<>;}	
				: 	CLASS className=ID LPAR (parDef{parameters.add($parDef.par)})* RPAR 
				    LCBRACK (varDec{fields.add($varDec.var)})* (methodDef{methods.add($methodDef.getName,$methodDef.methodSign)})* RCBRACK
				    {
				    	 $classObj = new Class($className,
				    	 					   fields, 
				    	 					   parameters, 
				    	 					   methods
				    	 );
				    };
				    
methodDef returns [Method methodSign]
				  @init{LinkedList<TypeBase> parameters = new LinkedList<>(); 
					    HashMap<String,Variable> varDec = new HashMap<>();
						LinkedList<Statement> stmts = new LinkedList<>(); }	
				  :	returnedType=type methodName=ID LPAR (parDef{parameters.add($parDef.par)})* RPAR {$methodSign = new Method($returnedType, $methodName, parameters) };




body returns [StmtBlock b]
			 : LCBRACK v=varDec (s=stmt)* RCBRACK {b = new StmtBlock($v.vars,s.stats)};

varDec returns [LinkedList<TypeBase> vars]
			   @init{ vars = new LinkedList<>();
			   		  TypeBase var = null; }		
     		:  (t=type v=variable SEMI  { var = $t.varType;
     								      var.setID($v.text); 
     		   	 						  $vars.add(var);}    )*;

parDef returns [LinkedList<TypeBase> pars]
				@init{pars = new LinkedList<>();
					  TypeBase par = null;}
				: t=type v=variable {par = $t.varType; 
									 par.setID($v.text); 
									 $pars.add(par);}
				  ( COMMA t=type v=variable {par = $t.varType; 
				  	      					 par.setID($v.text); 
				  							 $pars.add(par);    }   )*;

type returns [TypeBase varType] 
            : ID   {$varType = new TypeObject($ID.text);}
            | INT  {$varType = new TypeInt($INT.text);}
            | BOOL {$varType = new TypeBool($BOOL.text);};

variable	:   ID;

stmt returns [Statement s]
     		: SKIP SEMI {s = new Skip();}
            | ID EQUALS es=exprse SEMI {s = $es.exps}
            | IF (exprb)  THEN (stmt | stmtblock)  (ELSE (stmt | stmtblock) )?
            | RETURN e=expr SEMI {s = new Return($e.exp);}
            ;
            
stmtblock	: LCBRACK (stmt)* RCBRACK;
		

exprse		: expr 
			| element DOT ID LPAR (expr)* RPAR 
			| NEW ID LPAR (expr)* RPAR 
			| NEWACT ID LPAR (expr)* RPAR;

expr returns [Expression exp]
   		    : v=val      {$exp = $v.value;} 
			| el=element {$exp = $el.elem;}
			| exa=expra  {$exp = $exa.exprArit;}
			| exb=exprb	 {$exp = $exb.exprBool;};   



val returns [ExpressionValue value]
			: NULL   {$value = new ExpressionNullValue();}
			| NUMBER {$value = new ExpressionIntValue();} 
			| TRUE   {$value = new ExpressionBoolValue();}
			| FALSE  {$value = new ExpressionBoolValue();};


expra returns [Expression exprArit]
     		: l=expra o=('*'|'/') r=expra {$exprArit = new ExpressionBinaryOperation($l.exprArit,$o.text,$r.exprArit);}
    		| l=expra o=('+'|'-') r=expra {$exprArit = new ExpressionBinaryOperation($l.exprArit,$o.text,$r.exprArit);}
    		| NUMBER   					  {$exprArit = new TypeInt();}
    		| v=ID     					  {$exprArit = new Variable($v.text);}
    		| '(' expra ')'			
    		;
    	
exprb returns [Expression exprBool]
     		: NOT exprb	
			| exprb (OR | AND | EQUALS | DISTINCT | GT | LT | GEG | LEG) exprb    		
    		| expra 
    		| val 
    		| element  
    		| '(' exprb ')'
    		;
    		
element returns [Element elem]
 			@init{Element elem = null;} 
            : ID   	 {$elem = new Variable($ID.text);}
            | t=THIS {$elem = new ExpressionValue($t.text);};
            
                	
lcbrak		: LCBRACK	;
rcbrak		: RCBRACK	; 

//TOKENS
LPAR  	: '('	;
RPAR  	: ')'	;
RSBRACK : ']'	;
LSBRACK : '['	;
RCBRACK : '}'	;
LCBRACK : '{'	;
PLUS    : '+' 	;
MINUS   : '-' 	;
MULT    : '*' 	;
DIV     : '/' 	;
AND     : '&&' 	;
OR      : '||'	;
GT      : '>' 	;
LT      : '<' 	;
GEG     : '>='	;
LEG     : '<=' 	;
EQUALS  : '='	;
DISTINCT: '!='	;
NOT     : '!' 	;
SKIP    : 'skip';
COMMA   : ','	;
COLON   : ':'	;
SEMI    : ';'	;
DOT     : '.'	;
NULL    : 'null';
TRUE    : 'true';
FALSE   : 'false' ;
CLASS	: 'class' ;
RETURN	: 'return';
THIS	: 'this'  ;
NEW		: 'new'	  ;
NEWACT	: 'newActive' ;
IF		: 'if'	  ;
THEN	: 'then'  ;
ELSE	: 'else'  ;
INT		: 'int'	  ;
BOOL	: 'bool'  ;

fragment CHAR 	: 'a'..'z' |'A'..'Z' ;
ID              : CHAR (CHAR | DIGIT)* ;

fragment DIGIT	: '0'..'9';	
NUMBER          : DIGIT+;

//SCAPED SEQUENCES
WS              : (' '|'\t'|'\n'|'\r')-> skip;
LINECOMENTS 	: '//' (~('\n'|'\r'))* -> skip;
BLOCKCOMENTS    : '/*'( ~('/'|'*')|'/'~'*'|'*'~'/'|BLOCKCOMENTS)* '*/' -> skip;