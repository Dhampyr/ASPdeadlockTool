/* This file was generated with JastAdd2 (http://jastadd.org) version 2.1.4 */
package abs.frontend.ast;

import java.io.PrintStream;
import beaver.Symbol;
import java.io.*;
import abs.frontend.ast.*;
import abs.backend.erlang.*;
import java.util.Iterator;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeInferrerExtension;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeVariable;
import abs.frontend.typechecker.locationtypes.LocationType;
import abs.backend.erlang.ErlUtil.Mask;
import org.apache.commons.io.output.WriterOutputStream;
import java.nio.charset.Charset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import abs.backend.java.*;
import abs.backend.java.codegeneration.*;
import abs.backend.java.lib.runtime.*;
import abs.backend.java.lib.expr.*;
import abs.backend.java.lib.types.*;
import abs.backend.java.codegeneration.dynamic.*;
import abs.backend.java.codegeneration.JavaCode;
import abs.backend.java.codegeneration.JavaCodeGenerationException;
import java.util.Set;
import java.util.TreeSet;
import abs.backend.maude.MaudeCompiler;
import abs.backend.maude.MaudeCompilerHelper;
import java.io.PrintWriter;
import abs.backend.prettyprint.*;
import abs.backend.prolog.*;
import static abs.backend.prolog.PrologBackend.fieldTransform;
import static abs.backend.prolog.PrologBackend.initialToUpperCase;
import static abs.backend.prolog.PrologBackend.varTransform;
import static abs.backend.prolog.PrologBackend.strTransform;
import static abs.backend.prolog.PrologBackend.quote;
import java.util.HashSet;
import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.analyser.*;
import abs.frontend.typechecker.*;
import java.util.Collections;
import java.util.Map;
import abs.common.*;
import abs.frontend.typechecker.Type;
import abs.frontend.typechecker.DataTypeType;
import abs.frontend.ast.InterfaceDecl;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.frontend.parser.*;
import abs.frontend.mtvl.ChocoSolver;
import choco.Choco;
import choco.kernel.model.constraints.Constraint;
import choco.kernel.model.variables.integer.IntegerVariable;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;
import abs.frontend.mtvl.Types;
import abs.frontend.parser.ParserError;
import java.util.*;
import java.util.regex.*;
import abs.frontend.tests.*;
import abs.frontend.treecopy.ParseTreeCopyHelper;
import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.TypeCheckerHelper;
import abs.frontend.typechecker.KindedName;
import abs.frontend.typechecker.ResolvedName;
import javax.annotation.CheckForNull;
import abs.frontend.typechecker.KindedName.Kind;
import java.util.Arrays;
import abs.frontend.typechecker.ext.*;
/**
 * @ast node
 * @production ASTNode;

 */
public class ASTNode<T extends ASTNode> extends beaver.Symbol  implements Cloneable, Iterable<T> {
  /**
   * @aspect GenerateCoreABS
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/coreabs/GenerateCoreAbs.jadd:6
   */
  public void generateCoreABS(PrintStream stream) {
        // placeholder
        
        stream.println("// " + getClass().getSimpleName()
//                + " Declared in " + getModuleDecl().getFileName()
                + " line " + Symbol.getLine(getStart())
                + " column " + Symbol.getColumn(getStart())
                );
    }
  /**
   * @aspect doPrettyPrinter
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prettyprint/PrettyPrinter.jadd:28
   */
  public void doPrettyPrint(PrintWriter stream, ABSFormatter formatter) {
    }
  /**
   * @aspect GenerateProlog
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prolog/GenerateProlog.jadd:20
   */
  public void generateProlog(PrintStream s,ReachabilityInformation reachInfo){
        if (children != null)
            for (ASTNode<?> child : children) 
                if (child != null) child.generateProlog(s,reachInfo);
    }
  /**
   * @aspect collectReachableCode
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/prolog/collectReachableCode.jadd:11
   */
  public void collectReachableCode(ReachabilityInformation reachInfo){
        if (children != null)
            for (ASTNode<?> child : children) 
                if (child != null) child.collectReachableCode(reachInfo);
    }
  /**
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:10
   */
  public void setPosition(int startPos, int endPos) {
	    start = startPos;
	    end = endPos;
	}
  /**
   * @aspect ErrorCheck
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/ErrorCheck.jadd:22
   */
  void refined_ErrorCheck_ASTNode_collectErrors(SemanticErrorList c) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectErrors(c);
  }
  /**
   * @aspect NewExpCounter
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/NewExprCounter.jrag:9
   */
  protected int getNumberOfNewCogExpr() {
        int count = 0;
        for (int i = 0; i < getNumChild(); i++) {
            count += getChild(i).getNumberOfNewCogExpr();
        }
        return count;
    }
  /**
   * @aspect DeltaParameterSubstitution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/delta/DeltaParameterSubstitution.jadd:232
   */
  protected void applySubstitution(Map<String,Value> subst) throws DeltaModellingWithNodeException {
        for(int i = 0; i < getNumChild(); i++) {
            getChild(i).applySubstitution(subst);
        }
    }
  /**
   * @aspect OriginalCallResolver
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/delta/OriginalCallResolver.jadd:65
   */
  protected void resolveOriginalCalls(
            ModifyMethodModifier mod, 
            Collection<DeltaDecl> deltas) throws DeltaModellingException {
        
        for(int i = 0; i < getNumChild(); i++) {
            getChildNoTransform(i).resolveOriginalCalls(mod, deltas);
        }
    }
  /**
   * @aspect CSP
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/CSP.jadd:140
   */
  public Constraint collectConstraints(ChocoSolver s) {
		for(int i = 0; i < getNumChild(); i++)
			getChildNoTransform(i).collectConstraints(s);
	  return Choco.TRUE;
	}
  /**
   * @aspect CollectParents
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/CollectParents.jadd:11
   */
  public void collectParents(Set<String> features, Set<String> newParents) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectParents(features, newParents);
  }
  /**
   * @aspect CollectParents
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/CollectParents.jadd:22
   */
  public void collectParents(Set<String> newParents) {
    if (getParent() != null) getParent().collectParents(newParents); // go up!
  }
  /**
   * @aspect ErrorCheck
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/ErrorCheck.jadd:47
   */
  public void checkType(Types type, SemanticErrorList c) {
//    System.out.println("spreading check in constraint from...");
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).checkType(type,c);
  }
  /**
   * @aspect AbsolutePos
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/parser/AbsolutePos.jadd:2
   */
  protected int absolutePosition = -1;
  /**
   * @aspect AbsolutePos
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/parser/AbsolutePos.jadd:4
   */
  public void setAbsolutePosition(int abspos) {
    this.absolutePosition = abspos;
  }
  /**
   * @aspect AbsolutePos
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/parser/AbsolutePos.jadd:8
   */
  public int getAbsolutePosition() {
  	return absolutePosition;
  }
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:89
   */
  public void flushAll() {
        for (int i = 0; i < getNumChild(); i++)
            getChild(i).flushAll();
        flushCache();
        is$Final(false);
        in$Circle(false);
	}
  /**
   * @aspect DumpTree
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/DumpTree.jadd:5
   */
  public void dumpTree(String indent, java.io.PrintStream pStream) {
		pStream.println(indent + this.getClass().getName());
		String childIndent = indent + "  ";
		for(int i = 0; i < getNumChild(); i++)
			getChildNoTransform(i).dumpTree(childIndent, pStream);
	}
  /**
   * @aspect MyDumpTree
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/MyDumpTree.jadd:11
   */
  protected static java.util.regex.Pattern p =
        java.util.regex.Pattern.compile("([A-Z][a-zA-Z]*)@([\\da-f]+)");
  /**
   * @aspect MyDumpTree
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/MyDumpTree.jadd:14
   */
  protected void printInfo(PrintStream stream) {}
  /**
   * @aspect MyDumpTree
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/MyDumpTree.jadd:16
   */
  public void dump() {
		dump(System.out, 0, 0, false);
	}
  /**
   * @aspect MyDumpTree
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/MyDumpTree.jadd:20
   */
  protected void dump(PrintStream stream, int pattern, int level, boolean last)
	{
		java.util.regex.Matcher m = p.matcher(super.toString());
		String clsName = null;
		String address = null;
		
		int flag = pattern;
		int bit = 0;
		
		while (m.find()) {
			clsName = m.group(1);
			address = m.group(2);
		}
		
		// the above code doesn't work because toString() is frequently overridden
		clsName = getClass().getName();
		
		// General idea:
		// In the printed version of the AST, each line is composed of level(number) prefixes.
		// I used the pth bit of integer pattern to record which prefix at position p should
		// be printed. (p starts from 0). There are four cases:
		//   a. "|   ": if the pth bit is one
		//   b. "    ": if the pth bit is zero
		//   c. "|-- ": if the current node is the not the last child of its parent.
		//   d. "`-- ": if the current node is the last child of its parent.
		
		for (int i=0; i<level; i++) {
			if (i == level - 1) {
				if (!last) {
					stream.print("|-- ");
				}
				else {
					stream.print("`-- ");
				}
			}
			else {
				bit = flag & 0x00000001;
				if (bit != 0)
					stream.print("|   ");
				else
					stream.print("    ");
				flag >>= 1;
			}
		}

		// The node information followed by the prefixes.
		stream.print(clsName + ":[");		
		printInfo(stream);
		stream.println("]");		


		// Update the pattern.
		// If the current node is the last child of this level, then all its children
		// should not print prefix "|   " on position level.
		
		flag = pattern;
		flag = flag | (0x00000001 << level);
		
		for (int i=0; i<getNumChild(); i++) {
			if (i == getNumChild() - 1) {
				flag = pattern;
                //				getChild(i).dump(flag, level+1, true);
                getChildNoTransform(i).dump(stream, flag, level+1, true);
			}
			else {
                //				getChild(i).dump(flag, level+1, false);
                getChildNoTransform(i).dump(stream, flag, level+1, false);
			}
		}
	}
  /**
   * @aspect PrettyPrint
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/PrettyPrint.jadd:13
   */
  public String toString() {
        StringWriter writer = new StringWriter();
        PrintWriter w = new PrintWriter(writer);
        ABSFormatter f = new EmptyFormatter();
        prettyPrint(w,f);
        return writer.toString();
    }
  /**
   * @aspect PrettyPrint
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/PrettyPrint.jadd:21
   */
  public void prettyPrint(PrintWriter w, ABSFormatter f) {
        w.print(this.getClass().getSimpleName()+"(");
        prettyPrintChildren(w,f);
        w.print(")");
    }
  /**
   * @aspect PrettyPrint
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/tests/PrettyPrint.jadd:27
   */
  public void prettyPrintChildren(PrintWriter w, ABSFormatter f) {
        for(int i = 0; i < getNumChild(); i++) {
            if (i > 0) w.print(",");
            getChild(i).prettyPrint(w,f);
        }
    }
  /**
   * @aspect ParseTreeCopy
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/treecopy/ParseTreeCopy.jadd:26
   */
  public ASTNode parseTreeCopy() { return ParseTreeCopyHelper.parseTreeCopy(this); }
  /**
   * @aspect FileName
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/NodeNames.jrag:86
   */
  private String sourceFileName = null;
  /**
   * @aspect FileName
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/NodeNames.jrag:87
   */
  public void setFileName(String fileName) { this.sourceFileName = fileName; }
  /**
   * checks whether the two elements are defined in the same method or block
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:438
   */
  public boolean inSameMethodOrBlock(ASTNode<?> b) {
        return getContextMethod() != null && b.getContextMethod() == getContextMethod()
            || getContextBlock()  != null && b.getContextBlock() == getContextBlock();
    }
  /**
   * This method (presumably) finds the outermost match conforming to `clazz`.
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:446
   */
  @CheckForNull
    public ASTNode<?> calcContextNode(Class<?> clazz) {
        ASTNode<?> n = this;
        while (n != null) {
            ASTNode<?> parent = n.getParent();

            if (clazz.isInstance(n)) {
                if (parent == null)
                    return n;

                ASTNode<?> pn = parent.calcContextNode(clazz);
                if (pn != null)
                    return pn;
                else
                    return n;
            }
            n = parent;
        }
        return null;
    }
  /**
   * This method finds the closest parent conforming to `clazz`, starting from this
   * object's parent. May return null.
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:471
   */
  @CheckForNull
    public ASTNode<?> closestParent(Class<?> clazz) {
            ASTNode<?> n = getParent();
        while (n != null) {
            if (clazz.isInstance(n))
            	return n;
            else
                n = n.getParent();
        }
        return null;
    }
  /**
   * @aspect InitChecker
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/ext/InitChecker.jrag:5
   */
  void checkLegalInit(SemanticErrorList l, ErrorMessage msg) {
        for (ASTNode<?> n : this) {
            n.checkLegalInit(l, msg);
        }
    }
  /**
   * @declaredat ASTNode:1
   */
  public ASTNode() {
    super();
    init$Children();
  }
  /**
   * Initializes the child array to the correct size.
   * Initializes List and Opt nta children.
   * @apilevel internal
   * @ast method
   * @declaredat ASTNode:11
   */
  public void init$Children() {
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:16
   */
  private int childIndex;
  /**
   * @apilevel low-level
   * @declaredat ASTNode:21
   */
  public int getIndexOfChild(ASTNode node) {
    if (node == null) {
      return -1;
    }
    if (node.childIndex < numChildren && node == children[node.childIndex]) {
      return node.childIndex;
    }
    for(int i = 0; children != null && i < children.length; i++) {
      if(children[i] == node) {
        node.childIndex = i;
        return i;
      }
    }
    return -1;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:40
   */
  public static final boolean generatedWithCircularEnabled = true;
  /**
   * @apilevel internal
   * @declaredat ASTNode:44
   */
  public static final boolean generatedWithCacheCycle = true;
  /**
   * @apilevel internal
   * @declaredat ASTNode:48
   */
  public static final boolean generatedWithComponentCheck = false;
  /**
   * Parent pointer
   * @apilevel low-level
   * @declaredat ASTNode:54
   */
  protected ASTNode parent;
  /**
   * Child array
   * @apilevel low-level
   * @declaredat ASTNode:60
   */
  protected ASTNode[] children;
  /**
   * @apilevel internal
   * @declaredat ASTNode:65
   */
  protected static ASTNode$State state = new ASTNode$State();
  /**
   * @apilevel internal
   * @declaredat ASTNode:70
   */
  public final ASTNode$State state() {
    return state;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:77
   */
  public boolean in$Circle = false;
  /**
   * @apilevel internal
   * @declaredat ASTNode:82
   */
  public boolean in$Circle() {
    return in$Circle;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:89
   */
  public void in$Circle(boolean b) {
    in$Circle = b;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:96
   */
  public void debugRewrite(String info) {
    if(!parent.is$Final()) return;
      java.util.ArrayList key = new java.util.ArrayList(2);
      key.add(getParent());
      key.add(new Integer(getParent().getIndexOfChild(this)));
      java.util.ArrayList list;
      if(state().debugRewrite.containsKey(key))
        list = (java.util.ArrayList)state().debugRewrite.get(key);
    else {
      list = new java.util.ArrayList();
      state().debugRewrite.put(key, list);
    }
    list.add(info);
    if(list.size() > 100) {
      StringBuffer buf = new StringBuffer("Iteration count exceeded for rewrite:");
      for(java.util.Iterator iter = list.iterator(); iter.hasNext(); )
        buf.append("\n" + iter.next());
      throw new RuntimeException(buf.toString());
    }
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:120
   */
  public void debugRewriteRemove() {
    java.util.ArrayList key = new java.util.ArrayList(2);
    key.add(getParent());
    key.add(new Integer(getParent().getIndexOfChild(this)));
    state().debugRewrite.remove(key);
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:129
   */
  public boolean is$Final = false;
  /**
   * @apilevel internal
   * @declaredat ASTNode:133
   */
  public boolean is$Final() { return is$Final; }
  /**
   * @apilevel internal
   * @declaredat ASTNode:137
   */
  public void is$Final(boolean b) { is$Final = b; }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:142
   */
  public T getChild(int i) {

    ASTNode node = this.getChildNoTransform(i);
    if(node == null) {
      return null;
    }
    if(node.is$Final()) {
      return (T) node;
    }
    if(!node.mayHaveRewrite()) {
      node.is$Final(this.is$Final());
      return (T) node;
    }
    if(!node.in$Circle()) {
      int rewriteState;
      int num = this.state().boundariesCrossed;
      do {
        this.state().push(ASTNode$State.REWRITE_CHANGE);
        ASTNode oldNode = node;
        oldNode.in$Circle(true);
        node = node.rewriteTo();
        if(node != oldNode) {
          this.setChild(node, i);
        }
        oldNode.in$Circle(false);
        rewriteState = this.state().pop();
      } while(rewriteState == ASTNode$State.REWRITE_CHANGE);
      if(rewriteState == ASTNode$State.REWRITE_NOCHANGE && this.is$Final()) {
        node.is$Final(true);
        this.state().boundariesCrossed = num;
        node.debugRewriteRemove();
      } else {
      }
    } else if(this.is$Final() != node.is$Final()) {
      this.state().boundariesCrossed++;
    } else {
    }
    return (T) node;


  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:186
   */
  public void addChild(T node) {
    setChild(node, getNumChildNoTransform());
  }
  /**
   * <p><em>This method does not invoke AST transformations.</em></p>
   * @apilevel low-level
   * @declaredat ASTNode:193
   */
  public final T getChildNoTransform(int i) {
    if (children == null) {
      return null;
    }
    T child = (T)children[i];
    return child;
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:203
   */
  protected int numChildren;
  /**
   * @apilevel low-level
   * @declaredat ASTNode:208
   */
  protected int numChildren() {
    return numChildren;
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:215
   */
  public int getNumChild() {
    return numChildren();
  }
  /**
   * <p><em>This method does not invoke AST transformations.</em></p>
   * @apilevel low-level
   * @declaredat ASTNode:223
   */
  public final int getNumChildNoTransform() {
    return numChildren();
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:229
   */
  public void setChild(ASTNode node, int i) {
    debugNodeAttachment(node);
    if(children == null) {
      children = new ASTNode[(i+1>4 || !(this instanceof List))?i+1:4];
    } else if (i >= children.length) {
      ASTNode c[] = new ASTNode[i << 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = node;
    if(i >= numChildren) {
      numChildren = i+1;
    }
    if(node != null) {
      node.setParent(this);
      node.childIndex = i;
    }
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:250
   */
  public void insertChild(ASTNode node, int i) {
    debugNodeAttachment(node);
    if(children == null) {
      children = new ASTNode[(i+1>4 || !(this instanceof List))?i+1:4];
      children[i] = node;
    } else {
      ASTNode c[] = new ASTNode[children.length + 1];
      System.arraycopy(children, 0, c, 0, i);
      c[i] = node;
      if(i < children.length) {
        System.arraycopy(children, i, c, i+1, children.length-i);
        for(int j = i+1; j < c.length; ++j) {
          if(c[j] != null) {
            c[j].childIndex = j;
          }
        }
      }
      children = c;
    }
    numChildren++;
    if(node != null) {
      node.setParent(this);
      node.childIndex = i;
    }
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:278
   */
  public void removeChild(int i) {
    if(children != null) {
      ASTNode child = (ASTNode) children[i];
      if(child != null) {
        child.parent = null;
        child.childIndex = -1;
      }
      // Adding a check of this instance to make sure its a List, a move of children doesn't make
      // any sense for a node unless its a list. Also, there is a problem if a child of a non-List node is removed
      // and siblings are moved one step to the right, with null at the end.
      if (this instanceof List || this instanceof Opt) {
        System.arraycopy(children, i+1, children, i, children.length-i-1);
        children[children.length-1] = null;
        numChildren--;
        // fix child indices
        for(int j = i; j < numChildren; ++j) {
          if(children[j] != null) {
            child = (ASTNode) children[j];
            child.childIndex = j;
          }
        }
      } else {
        children[i] = null;
      }
    }
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:307
   */
  public ASTNode getParent() {
    if(parent != null && ((ASTNode) parent).is$Final() != is$Final()) {
      state().boundariesCrossed++;
    }
    ;
    return (ASTNode) parent;
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:317
   */
  public void setParent(ASTNode node) {
    parent = node;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:323
   */
  protected boolean debugNodeAttachmentIsRoot() {
    return false;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:330
   */
  private static void debugNodeAttachment(ASTNode node) {
    if(node == null) {
      throw new RuntimeException("Trying to assign null to a tree child node");
    }

    while(node != null && !node.debugNodeAttachmentIsRoot()) {
      if(node.in$Circle())
        return;
      ASTNode parent = (ASTNode) node.parent;
      if(parent != null && parent.getIndexOfChild(node) == -1) {
        return;
      }
      node = parent;
    }

    if(node != null) {
      throw new RuntimeException("Trying to insert the same tree at multiple tree locations");
    }
  }
  /**
   * @declaredat ASTNode:350
   */
  protected boolean duringSqlProc() {
  if(state().duringSqlProc == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @declaredat ASTNode:359
   */
  protected boolean duringVarResolution() {
  if(state().duringVarResolution == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @declaredat ASTNode:368
   */
  protected boolean duringTypeResolution() {
  if(state().duringTypeResolution == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @declaredat ASTNode:377
   */
  protected boolean duringGenerateCoreABS() {
  if(state().duringGenerateCoreABS == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @declaredat ASTNode:386
   */
  protected boolean duringSqlRewrites() {
  if(state().duringSqlRewrites == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @declaredat ASTNode:395
   */
  protected boolean duringConstantFolding() {
  if(state().duringConstantFolding == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @declaredat ASTNode:404
   */
  protected boolean duringAttributeValueResolution() {
  if(state().duringAttributeValueResolution == 0) {
    return false;
  } else {
    state().pop();
    state().push(ASTNode$State.REWRITE_INTERRUPT);
    return true;
  }
}
  /**
   * @apilevel low-level
   * @declaredat ASTNode:456
   */
  public java.util.Iterator<T> iterator() {
    return new java.util.Iterator<T>() {
      private int counter = 0;
      public boolean hasNext() {
        return counter < getNumChild();
      }
      public T next() {
        if(hasNext())
          return (T)getChild(counter++);
        else
          return null;
      }
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:476
   */
  public boolean mayHaveRewrite() {
    return false;
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:482
   */
  public void flushCache() {
    getStartPos_visited = -1;
    getEndPos_visited = -1;
    hasChildren_visited = -1;
    getStartLine_visited = -1;
    getStartColumn_visited = -1;
    getEndLine_visited = -1;
    getEndColumn_visited = -1;
    getNodeAnnotations_visited = -1;
    getInheritedAnnotationValue_String_visited = null;
    getNodeWithAnnotation_String_visited = null;
    hasInheritedAnnotation_String_visited = null;
    ancestorDistance_ASTNode_visited = null;
    activeDbTransaction_visited = -1;
    activeDbConnection_visited = -1;
    getFileName_visited = -1;
    getModuleDecl_visited = -1;
    getModuleDecl_computed = false;
    getModuleDecl_value = null;
    getContextDecl_visited = -1;
    getContextDecl_computed = false;
    getContextDecl_value = null;
    getContextMethod_visited = -1;
    getContextMethod_computed = false;
    getContextMethod_value = null;
    getContextBlock_visited = -1;
    getContextBlock_computed = false;
    getContextBlock_value = null;
    getCompilationUnit_visited = -1;
    getCompilationUnit_computed = false;
    getCompilationUnit_value = null;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:517
   */
  public void flushCollectionCache() {
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:522
   */
  public ASTNode<T> clone() throws CloneNotSupportedException {
    ASTNode node = (ASTNode) super.clone();
    node.getStartPos_visited = -1;
    node.getEndPos_visited = -1;
    node.hasChildren_visited = -1;
    node.getStartLine_visited = -1;
    node.getStartColumn_visited = -1;
    node.getEndLine_visited = -1;
    node.getEndColumn_visited = -1;
    node.getNodeAnnotations_visited = -1;
    node.getInheritedAnnotationValue_String_visited = null;
    node.getNodeWithAnnotation_String_visited = null;
    node.hasInheritedAnnotation_String_visited = null;
    node.ancestorDistance_ASTNode_visited = null;
    node.activeDbTransaction_visited = -1;
    node.activeDbConnection_visited = -1;
    node.getFileName_visited = -1;
    node.getModuleDecl_visited = -1;
    node.getModuleDecl_computed = false;
    node.getModuleDecl_value = null;
    node.getContextDecl_visited = -1;
    node.getContextDecl_computed = false;
    node.getContextDecl_value = null;
    node.getContextMethod_visited = -1;
    node.getContextMethod_computed = false;
    node.getContextMethod_value = null;
    node.getContextBlock_visited = -1;
    node.getContextBlock_computed = false;
    node.getContextBlock_value = null;
    node.getCompilationUnit_visited = -1;
    node.getCompilationUnit_computed = false;
    node.getCompilationUnit_value = null;
    node.in$Circle(false);
    node.is$Final(false);
    return node;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:561
   */
  public ASTNode<T> copy() {
    try {
      ASTNode node = (ASTNode) clone();
      node.parent = null;
      if(children != null) {
        node.children = (ASTNode[]) children.clone();
      }
      return node;
    } catch (CloneNotSupportedException e) {
      throw new Error("Error: clone not supported for " + getClass().getName());
    }
  }
  /**
   * Create a deep copy of the AST subtree at this node.
   * The copy is dangling, i.e. has no parent.
   * @return dangling copy of the subtree at this node
   * @apilevel low-level
   * @declaredat ASTNode:579
   */
  public ASTNode<T> fullCopy() {
    ASTNode tree = (ASTNode) copy();
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        ASTNode child = (ASTNode) children[i];
        if(child != null) {
          child = child.fullCopy();
          tree.setChild(child, i);
        }
      }
    }
    return tree;
  }
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:47
   */
    void collectErrors(SemanticErrorList c) {
        final List<Annotation> annotations = getNodeAnnotations();
        if (CompilerUtils.hasAnnotation(annotations, "SqlSync") &&
                CompilerUtils.hasAnnotation(annotations, "SqlAsync"))
            c.add(new SemanticError(annotations,
                    ErrorMessage.SQL_SYNC_COMBINED_WITH_ASYNC, new String[0]));
        refined_ErrorCheck_ASTNode_collectErrors(c);
    }
  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/Variables.jrag:14
   */
    protected void collect_contributors_Model_ints() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_Model_ints();
    }
  }
  protected void contributeTo_Model_Model_ints(RepeatMap<String,BoundaryInt[]> collection) {
  }

  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/Variables.jrag:24
   */
    protected void collect_contributors_Model_bools() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_Model_bools();
    }
  }
  protected void contributeTo_Model_Model_bools(RepeatList collection) {
  }

  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/mtvl/Variables.jrag:25
   */
    protected void collect_contributors_Model_features() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_Model_features();
    }
  }
  protected void contributeTo_Model_Model_features(RepeatList collection) {
  }

  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/ErrorCheck.jadd:74
   */
    protected void collect_contributors_DeltaDecl_getErrsWithinDelta() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_DeltaDecl_getErrsWithinDelta();
    }
  }
  protected void contributeTo_DeltaDecl_DeltaDecl_getErrsWithinDelta(SemanticErrorList collection) {
  }

  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/TypeHierarchy.jadd:22
   */
    protected void collect_contributors_InterfaceDecl_getDirectSubTypes() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_InterfaceDecl_getDirectSubTypes();
    }
  }
  protected void contributeTo_InterfaceDecl_InterfaceDecl_getDirectSubTypes(Collection<HasTypeHierarchy> collection) {
  }

  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/TypeHierarchy.jadd:31
   */
    protected void collect_contributors_InterfaceDecl_getSubTypes() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_InterfaceDecl_getSubTypes();
    }
  }
  protected void contributeTo_InterfaceDecl_InterfaceDecl_getSubTypes(Collection<HasTypeHierarchy> collection) {
  }

  /**
   * @aspect <NoAspect>
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/backend/coreabs/GenerateCoreAbs.jadd:51
   */
    protected void collect_contributors_Stmt_getAACs() {
    for(int i = 0; i < getNumChild(); i++) {
      getChild(i).collect_contributors_Stmt_getAACs();
    }
  }
  protected void contributeTo_Stmt_Stmt_getAACs(Set<AwaitAsyncCall> collection) {
  }

  /**
   * @apilevel internal
   */
  protected int getStartPos_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:4
   */
  public int getStartPos() {
    ASTNode$State state = state();
    if (getStartPos_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getStartPos in class: org.jastadd.ast.AST.SynDecl");
    }
    getStartPos_visited = state().boundariesCrossed;
    try {  return getStart();  }
    finally {
      getStartPos_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getEndPos_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:5
   */
  public int getEndPos() {
    ASTNode$State state = state();
    if (getEndPos_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getEndPos in class: org.jastadd.ast.AST.SynDecl");
    }
    getEndPos_visited = state().boundariesCrossed;
    try {  return getEnd();  }
    finally {
      getEndPos_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int hasChildren_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:7
   */
  public boolean hasChildren() {
    ASTNode$State state = state();
    if (hasChildren_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: hasChildren in class: org.jastadd.ast.AST.SynDecl");
    }
    hasChildren_visited = state().boundariesCrossed;
    try {  return getNumChild() > 0;  }
    finally {
      hasChildren_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getStartLine_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:15
   */
  public int getStartLine() {
    ASTNode$State state = state();
    if (getStartLine_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getStartLine in class: org.jastadd.ast.AST.SynDecl");
    }
    getStartLine_visited = state().boundariesCrossed;
    try {  return beaver.Symbol.getLine(getStart());  }
    finally {
      getStartLine_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getStartColumn_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:16
   */
  public int getStartColumn() {
    ASTNode$State state = state();
    if (getStartColumn_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getStartColumn in class: org.jastadd.ast.AST.SynDecl");
    }
    getStartColumn_visited = state().boundariesCrossed;
    try {  return beaver.Symbol.getColumn(getStart());  }
    finally {
      getStartColumn_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getEndLine_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:17
   */
  public int getEndLine() {
    ASTNode$State state = state();
    if (getEndLine_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getEndLine in class: org.jastadd.ast.AST.SynDecl");
    }
    getEndLine_visited = state().boundariesCrossed;
    try {  return beaver.Symbol.getLine(getEnd());  }
    finally {
      getEndLine_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getEndColumn_visited = -1;
  /**
   * @attribute syn
   * @aspect BackPositions
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/analyser/BackPositions.jrag:18
   */
  public int getEndColumn() {
    ASTNode$State state = state();
    if (getEndColumn_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getEndColumn in class: org.jastadd.ast.AST.SynDecl");
    }
    getEndColumn_visited = state().boundariesCrossed;
    try {  return beaver.Symbol.getColumn(getEnd());  }
    finally {
      getEndColumn_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getNodeAnnotations_visited = -1;
  /**
   * @attribute syn
   * @aspect SqlHelpers
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlHelpers.jadd:4
   */
  public List<Annotation> getNodeAnnotations() {
    ASTNode$State state = state();
    if (getNodeAnnotations_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getNodeAnnotations in class: org.jastadd.ast.AST.SynDecl");
    }
    getNodeAnnotations_visited = state().boundariesCrossed;
    try {  return new List<Annotation>();  }
    finally {
      getNodeAnnotations_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected java.util.Map getInheritedAnnotationValue_String_visited;
  /**
   * @attribute syn
   * @aspect SqlHelpers
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlHelpers.jadd:11
   */
  public PureExp getInheritedAnnotationValue(String name) {
    Object _parameters = name;
    if(getInheritedAnnotationValue_String_visited == null) getInheritedAnnotationValue_String_visited = new java.util.HashMap(4);
    ASTNode$State state = state();
    if (Integer.valueOf(state().boundariesCrossed).equals(getInheritedAnnotationValue_String_visited.get(_parameters))) {
      throw new RuntimeException("Circular definition of attr: getInheritedAnnotationValue in class: org.jastadd.ast.AST.SynDecl");
    }
    getInheritedAnnotationValue_String_visited.put(_parameters, Integer.valueOf(state().boundariesCrossed));
    try {
            final PureExp exp = CompilerUtils.getAnnotationValue(getNodeAnnotations(), name);
            if (exp != null)
                return exp;
            if (getParent() == null)
                return null;
            return getParent().getInheritedAnnotationValue(name);
        }
    finally {
      getInheritedAnnotationValue_String_visited.remove(_parameters);
    }
  }
  /**
   * @apilevel internal
   */
  protected java.util.Map getNodeWithAnnotation_String_visited;
  /**
   * @attribute syn
   * @aspect SqlHelpers
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlHelpers.jadd:20
   */
  public ASTNode getNodeWithAnnotation(String annotation) {
    Object _parameters = annotation;
    if(getNodeWithAnnotation_String_visited == null) getNodeWithAnnotation_String_visited = new java.util.HashMap(4);
    ASTNode$State state = state();
    if (Integer.valueOf(state().boundariesCrossed).equals(getNodeWithAnnotation_String_visited.get(_parameters))) {
      throw new RuntimeException("Circular definition of attr: getNodeWithAnnotation in class: org.jastadd.ast.AST.SynDecl");
    }
    getNodeWithAnnotation_String_visited.put(_parameters, Integer.valueOf(state().boundariesCrossed));
    try {
            if (CompilerUtils.hasAnnotation(getNodeAnnotations(), annotation))
                return this;
            if (getParent() == null)
                return null;
            return getParent().getNodeWithAnnotation(annotation);
        }
    finally {
      getNodeWithAnnotation_String_visited.remove(_parameters);
    }
  }
  /**
   * @apilevel internal
   */
  protected java.util.Map hasInheritedAnnotation_String_visited;
  /**
   * @attribute syn
   * @aspect SqlHelpers
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlHelpers.jadd:28
   */
  public boolean hasInheritedAnnotation(String annotation) {
    Object _parameters = annotation;
    if(hasInheritedAnnotation_String_visited == null) hasInheritedAnnotation_String_visited = new java.util.HashMap(4);
    ASTNode$State state = state();
    if (Integer.valueOf(state().boundariesCrossed).equals(hasInheritedAnnotation_String_visited.get(_parameters))) {
      throw new RuntimeException("Circular definition of attr: hasInheritedAnnotation in class: org.jastadd.ast.AST.SynDecl");
    }
    hasInheritedAnnotation_String_visited.put(_parameters, Integer.valueOf(state().boundariesCrossed));
    try {  return getNodeWithAnnotation(annotation) != null;  }
    finally {
      hasInheritedAnnotation_String_visited.remove(_parameters);
    }
  }
  /**
   * @apilevel internal
   */
  protected java.util.Map ancestorDistance_ASTNode_visited;
  /**
   * @attribute syn
   * @aspect SqlHelpers
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlHelpers.jadd:36
   */
  public int ancestorDistance(ASTNode ancestor) {
    Object _parameters = ancestor;
    if(ancestorDistance_ASTNode_visited == null) ancestorDistance_ASTNode_visited = new java.util.HashMap(4);
    ASTNode$State state = state();
    if (Integer.valueOf(state().boundariesCrossed).equals(ancestorDistance_ASTNode_visited.get(_parameters))) {
      throw new RuntimeException("Circular definition of attr: ancestorDistance in class: org.jastadd.ast.AST.SynDecl");
    }
    ancestorDistance_ASTNode_visited.put(_parameters, Integer.valueOf(state().boundariesCrossed));
    try {
            if (this == ancestor)
                return 0;
            if (getParent() == null)
                return -1;
            int distance = getParent().ancestorDistance(ancestor);
            return distance == -1 ? -1 : distance + 1;
        }
    finally {
      ancestorDistance_ASTNode_visited.remove(_parameters);
    }
  }
  /**
   * @apilevel internal
   */
  protected int activeDbTransaction_visited = -1;
  /**
   * @attribute syn
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:21
   */
  public PureExp activeDbTransaction() {
    ASTNode$State state = state();
    if (activeDbTransaction_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: activeDbTransaction in class: org.jastadd.ast.AST.SynDecl");
    }
    activeDbTransaction_visited = state().boundariesCrossed;
    try {  return getInheritedAnnotationValue("TX");  }
    finally {
      activeDbTransaction_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int activeDbConnection_visited = -1;
  /**
   * @attribute syn
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:22
   */
  public PureExp activeDbConnection() {
    ASTNode$State state = state();
    if (activeDbConnection_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: activeDbConnection in class: org.jastadd.ast.AST.SynDecl");
    }
    activeDbConnection_visited = state().boundariesCrossed;
    try {  return getInheritedAnnotationValue("DatabaseConnection");  }
    finally {
      activeDbConnection_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getFileName_visited = -1;
  /**
   * @attribute syn
   * @aspect FileName
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/NodeNames.jrag:88
   */
  public String getFileName() {
    ASTNode$State state = state();
    if (getFileName_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getFileName in class: org.jastadd.ast.AST.SynDecl");
    }
    getFileName_visited = state().boundariesCrossed;
    try {  return this.sourceFileName == null ? getParent().getFileName() : this.sourceFileName;  }
    finally {
      getFileName_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int getModuleDecl_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getModuleDecl_computed = false;
  /**
   * @apilevel internal
   */
  protected ModuleDecl getModuleDecl_value;
  /**
   * @attribute syn
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:420
   */
  public ModuleDecl getModuleDecl() {
    if(getModuleDecl_computed) {
      return getModuleDecl_value;
    }
    ASTNode$State state = state();
    if (getModuleDecl_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getModuleDecl in class: org.jastadd.ast.AST.SynDecl");
    }
    getModuleDecl_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getModuleDecl_value = getModuleDecl_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getModuleDecl_computed = true;
    } else {
    }

    getModuleDecl_visited = -1;
    return getModuleDecl_value;
  }
  /**
   * @apilevel internal
   */
  private ModuleDecl getModuleDecl_compute() {  return (ModuleDecl) calcContextNode(ModuleDecl.class);  }
  /**
   * @apilevel internal
   */
  protected int getContextDecl_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getContextDecl_computed = false;
  /**
   * @apilevel internal
   */
  protected Decl getContextDecl_value;
  /**
   * Return this objects surrounding declaration. Uses the Null Object Pattern,
   * so don't cast the result, as it may be an UnknownDecl.
   * @attribute syn
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:425
   */
  public Decl getContextDecl() {
    if(getContextDecl_computed) {
      return getContextDecl_value;
    }
    ASTNode$State state = state();
    if (getContextDecl_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getContextDecl in class: org.jastadd.ast.AST.SynDecl");
    }
    getContextDecl_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getContextDecl_value = getContextDecl_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getContextDecl_computed = true;
    } else {
    }

    getContextDecl_visited = -1;
    return getContextDecl_value;
  }
  /**
   * @apilevel internal
   */
  private Decl getContextDecl_compute() {
        Decl d = (Decl) calcContextNode(Decl.class);
        return (d == null ? Model.unknownDecl : d);
      }
  /**
   * @apilevel internal
   */
  protected int getContextMethod_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getContextMethod_computed = false;
  /**
   * @apilevel internal
   */
  protected MethodImpl getContextMethod_value;
  /**
   * @attribute syn
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:429
   */
  public MethodImpl getContextMethod() {
    if(getContextMethod_computed) {
      return getContextMethod_value;
    }
    ASTNode$State state = state();
    if (getContextMethod_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getContextMethod in class: org.jastadd.ast.AST.SynDecl");
    }
    getContextMethod_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getContextMethod_value = getContextMethod_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getContextMethod_computed = true;
    } else {
    }

    getContextMethod_visited = -1;
    return getContextMethod_value;
  }
  /**
   * @apilevel internal
   */
  private MethodImpl getContextMethod_compute() {  return (MethodImpl) calcContextNode(MethodImpl.class);  }
  /**
   * @apilevel internal
   */
  protected int getContextBlock_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getContextBlock_computed = false;
  /**
   * @apilevel internal
   */
  protected Block getContextBlock_value;
  /**
   * @attribute syn
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:430
   */
  public Block getContextBlock() {
    if(getContextBlock_computed) {
      return getContextBlock_value;
    }
    ASTNode$State state = state();
    if (getContextBlock_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getContextBlock in class: org.jastadd.ast.AST.SynDecl");
    }
    getContextBlock_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getContextBlock_value = getContextBlock_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getContextBlock_computed = true;
    } else {
    }

    getContextBlock_visited = -1;
    return getContextBlock_value;
  }
  /**
   * @apilevel internal
   */
  private Block getContextBlock_compute() {  return (Block) calcContextNode(Block.class);  }
  /**
   * @apilevel internal
   */
  protected int getCompilationUnit_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getCompilationUnit_computed = false;
  /**
   * @apilevel internal
   */
  protected CompilationUnit getCompilationUnit_value;
  /** returns the parent compilation unit of this node *
   * @attribute syn
   * @aspect TypeResolution
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/typechecker/TypeResolution.jrag:433
   */
  public CompilationUnit getCompilationUnit() {
    if(getCompilationUnit_computed) {
      return getCompilationUnit_value;
    }
    ASTNode$State state = state();
    if (getCompilationUnit_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getCompilationUnit in class: org.jastadd.ast.AST.SynDecl");
    }
    getCompilationUnit_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getCompilationUnit_value = getCompilationUnit_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getCompilationUnit_computed = true;
    } else {
    }

    getCompilationUnit_visited = -1;
    return getCompilationUnit_value;
  }
  /**
   * @apilevel internal
   */
  private CompilationUnit getCompilationUnit_compute() {  return (CompilationUnit) calcContextNode(CompilationUnit.class);  }
  /**
   * @apilevel internal
   */
  public ASTNode rewriteTo() {    if(state().peek() == ASTNode$State.REWRITE_CHANGE) {
      state().pop();
      state().push(ASTNode$State.REWRITE_NOCHANGE);
    }
    return this;
  }  /**
   * @apilevel internal
   */
  public Set<String> Define_Set_String__getNonLeafs(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_Set_String__getNonLeafs(this, caller);
  }
  /**
   * @apilevel internal
   */
  public ModuleDecl Define_ModuleDecl_lookupModule(ASTNode caller, ASTNode child, String name) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_ModuleDecl_lookupModule(this, caller, name);
  }
  /**
   * @apilevel internal
   */
  public Decl Define_Decl_lookup(ASTNode caller, ASTNode child, KindedName name) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_Decl_lookup(this, caller, name);
  }
  /**
   * @apilevel internal
   */
  public Model Define_Model_getModel(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_Model_getModel(this, caller);
  }
  /**
   * @apilevel internal
   */
  public VarOrFieldDecl Define_VarOrFieldDecl_lookupVarOrFieldName(ASTNode caller, ASTNode child, String name, boolean fieldOnly) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_VarOrFieldDecl_lookupVarOrFieldName(this, caller, name, fieldOnly);
  }
  /**
   * @apilevel internal
   */
  public ModuleDecl Define_ModuleDecl_getModuleDecl(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_ModuleDecl_getModuleDecl(this, caller);
  }
  /**
   * @apilevel internal
   */
  public DataTypeDecl Define_DataTypeDecl_getDataTypeDecl(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_DataTypeDecl_getDataTypeDecl(this, caller);
  }
  /**
   * @apilevel internal
   */
  public String Define_String_deltaName(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_String_deltaName(this, caller);
  }
  /**
   * @apilevel internal
   */
  public DeltaDecl Define_DeltaDecl_getDelta(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_DeltaDecl_getDelta(this, caller);
  }
  /**
   * @apilevel internal
   */
  public String Define_String_targetModuleName(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_String_targetModuleName(this, caller);
  }
  /**
   * @apilevel internal
   */
  public String Define_String_targetClassName(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_String_targetClassName(this, caller);
  }
  /**
   * @apilevel internal
   */
  public String Define_String_targetQualifiedClassName(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_String_targetQualifiedClassName(this, caller);
  }
  /**
   * @apilevel internal
   */
  public ModifyClassModifier Define_ModifyClassModifier_getModifyClassModifier(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_ModifyClassModifier_getModifyClassModifier(this, caller);
  }
  /**
   * @apilevel internal
   */
  public boolean Define_boolean_isContextImperative(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_boolean_isContextImperative(this, caller);
  }
  /**
   * @apilevel internal
   */
  public List<Annotation> Define_List_Annotation__getAnnotations(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_List_Annotation__getAnnotations(this, caller);
  }
  /**
   * @apilevel internal
   */
  public Type Define_Type_getPatternExpType(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_Type_getPatternExpType(this, caller);
  }
  /**
   * @apilevel internal
   */
  public Type Define_Type_getInhType(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_Type_getInhType(this, caller);
  }
  /**
   * @apilevel internal
   */
  public ProductLine Define_ProductLine_getProductLine(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_ProductLine_getProductLine(this, caller);
  }
  /**
   * @apilevel internal
   */
  public String Define_String_pname(ASTNode caller, ASTNode child) {
        if(getParent() == null) throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
    return getParent().Define_String_pname(this, caller);
  }
}
