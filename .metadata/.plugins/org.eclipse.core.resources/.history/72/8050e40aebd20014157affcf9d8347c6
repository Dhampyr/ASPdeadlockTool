package abs.frontend.ast;

import java.io.PrintStream;
import beaver.Symbol;
import java.io.*;
import abs.frontend.ast.*;
import abs.backend.erlang.*;
import java.util.Iterator;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeInferrerExtension;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeVariable;
import abs.frontend.typechecker.locationtypes.LocationType;
import abs.backend.erlang.ErlUtil.Mask;
import org.apache.commons.io.output.WriterOutputStream;
import java.nio.charset.Charset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import abs.backend.java.*;
import abs.backend.java.codegeneration.*;
import abs.backend.java.lib.runtime.*;
import abs.backend.java.lib.expr.*;
import abs.backend.java.lib.types.*;
import abs.backend.java.codegeneration.dynamic.*;
import abs.backend.java.codegeneration.JavaCode;
import abs.backend.java.codegeneration.JavaCodeGenerationException;
import java.util.Set;
import java.util.TreeSet;
import abs.backend.maude.MaudeCompiler;
import abs.backend.maude.MaudeCompilerHelper;
import java.io.PrintWriter;
import abs.backend.prettyprint.*;
import abs.backend.prolog.*;
import static abs.backend.prolog.PrologBackend.fieldTransform;
import static abs.backend.prolog.PrologBackend.initialToUpperCase;
import static abs.backend.prolog.PrologBackend.varTransform;
import static abs.backend.prolog.PrologBackend.strTransform;
import static abs.backend.prolog.PrologBackend.quote;
import java.util.HashSet;
import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.analyser.*;
import abs.frontend.typechecker.*;
import java.util.Collections;
import java.util.Map;
import abs.common.*;
import abs.frontend.typechecker.Type;
import abs.frontend.typechecker.DataTypeType;
import abs.frontend.ast.InterfaceDecl;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.frontend.parser.*;
import abs.frontend.mtvl.ChocoSolver;
import choco.Choco;
import choco.kernel.model.constraints.Constraint;
import choco.kernel.model.variables.integer.IntegerVariable;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;
import abs.frontend.mtvl.Types;
import abs.frontend.parser.ParserError;
import java.util.*;
import java.util.regex.*;
import abs.frontend.tests.*;
import abs.frontend.treecopy.ParseTreeCopyHelper;
import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.TypeCheckerHelper;
import abs.frontend.typechecker.KindedName;
import abs.frontend.typechecker.ResolvedName;
import javax.annotation.CheckForNull;
import abs.frontend.typechecker.KindedName.Kind;
import java.util.Arrays;
import abs.frontend.typechecker.ext.*;
/**
 * @apilevel internal
 * @ast class
 * @declaredat ASTNode:4
 */
public class ASTNode$State extends java.lang.Object {

  /**
   * @apilevel internal
   */
  public boolean LAST_CYCLE = false;


  /**
   * @apilevel internal
   */
  public boolean IN_CIRCLE = false;



  /**
   * @apilevel internal
   */
  public int CIRCLE_INDEX = 1;



  /**
   * @apilevel internal
   */
  public boolean CHANGE = false;



  /**
   * @apilevel internal
   */
  public boolean RESET_CYCLE = false;



  /**
   * @apilevel internal
   */
  static public class CircularValue {
    Object value;
    int visited = -1;
  }



  /**
   * @apilevel internal
   */
  public java.util.Map debugRewrite = new java.util.HashMap(4);


  /**
   * @apilevel internal
   */
  public static final int REWRITE_CHANGE = 1;



  /**
   * @apilevel internal
   */
  public static final int REWRITE_NOCHANGE = 2;



  /**
   * @apilevel internal
   */
  public static final int REWRITE_INTERRUPT = 3;



  public int boundariesCrossed = 0;



  // state code
  private int[] stack;



  private int pos;



  public ASTNode$State() {
    stack = new int[64];
    pos = 0;
  }



  private void ensureSize(int size) {
    if(size < stack.length)
      return;
    int[] newStack = new int[stack.length * 2];
    System.arraycopy(stack, 0, newStack, 0, stack.length);
    stack = newStack;
  }



  public void push(int i) {
    ensureSize(pos+1);
    stack[pos++] = i;
  }



  public int pop() {
    return stack[--pos];
  }



  public int peek() {
    return stack[pos-1];
  }



  /**
   * @apilevel internal
   */
  static class IdentityHashSet extends java.util.AbstractSet implements java.util.Set {

    public IdentityHashSet(int initialCapacity) {
      map = new java.util.IdentityHashMap(initialCapacity);
    }

    private java.util.IdentityHashMap map;

    private static final Object PRESENT = new Object();

    public java.util.Iterator iterator() {
      return map.keySet().iterator();
    }

    public int size() {
      return map.size();
    }

    public boolean isEmpty() {
      return map.isEmpty();
    }

    public boolean contains(Object o) {
      return map.containsKey(o);
    }

    public boolean add(Object o) {
      return map.put(o, PRESENT)==null;
    }

    public boolean remove(Object o) {
      return map.remove(o)==PRESENT;
    }

    public void clear() {
      map.clear();
    }
  }

protected int duringSqlProc = 0;

protected int duringVarResolution = 0;

protected int duringTypeResolution = 0;

protected int duringGenerateCoreABS = 0;

protected int duringSqlRewrites = 0;

protected int duringConstantFolding = 0;

protected int duringAttributeValueResolution = 0;

public void reset() {
    IN_CIRCLE = false;
    CIRCLE_INDEX = 1;
    CHANGE = false;
    LAST_CYCLE = false;

    boundariesCrossed = 0;
    if(duringSqlProc != 0) {
      System.out.println("Warning: resetting duringSqlProc");
      duringSqlProc = 0;
    }
    if(duringVarResolution != 0) {
      System.out.println("Warning: resetting duringVarResolution");
      duringVarResolution = 0;
    }
    if(duringTypeResolution != 0) {
      System.out.println("Warning: resetting duringTypeResolution");
      duringTypeResolution = 0;
    }
    if(duringGenerateCoreABS != 0) {
      System.out.println("Warning: resetting duringGenerateCoreABS");
      duringGenerateCoreABS = 0;
    }
    if(duringSqlRewrites != 0) {
      System.out.println("Warning: resetting duringSqlRewrites");
      duringSqlRewrites = 0;
    }
    if(duringConstantFolding != 0) {
      System.out.println("Warning: resetting duringConstantFolding");
      duringConstantFolding = 0;
    }
    if(duringAttributeValueResolution != 0) {
      System.out.println("Warning: resetting duringAttributeValueResolution");
      duringAttributeValueResolution = 0;
    }
    debugRewrite = new java.util.HashMap(4);

  }


}
