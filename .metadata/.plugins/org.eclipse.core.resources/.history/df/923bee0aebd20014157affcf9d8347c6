/* This file was generated with JastAdd2 (http://jastadd.org) version 2.1.4 */
package abs.frontend.ast;

import java.io.PrintStream;
import beaver.Symbol;
import java.io.*;
import abs.frontend.ast.*;
import abs.backend.erlang.*;
import java.util.Iterator;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeInferrerExtension;
import abs.frontend.typechecker.locationtypes.infer.LocationTypeVariable;
import abs.frontend.typechecker.locationtypes.LocationType;
import abs.backend.erlang.ErlUtil.Mask;
import org.apache.commons.io.output.WriterOutputStream;
import java.nio.charset.Charset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import abs.backend.java.*;
import abs.backend.java.codegeneration.*;
import abs.backend.java.lib.runtime.*;
import abs.backend.java.lib.expr.*;
import abs.backend.java.lib.types.*;
import abs.backend.java.codegeneration.dynamic.*;
import abs.backend.java.codegeneration.JavaCode;
import abs.backend.java.codegeneration.JavaCodeGenerationException;
import java.util.Set;
import java.util.TreeSet;
import abs.backend.maude.MaudeCompiler;
import abs.backend.maude.MaudeCompilerHelper;
import java.io.PrintWriter;
import abs.backend.prettyprint.*;
import abs.backend.prolog.*;
import static abs.backend.prolog.PrologBackend.fieldTransform;
import static abs.backend.prolog.PrologBackend.initialToUpperCase;
import static abs.backend.prolog.PrologBackend.varTransform;
import static abs.backend.prolog.PrologBackend.strTransform;
import static abs.backend.prolog.PrologBackend.quote;
import java.util.HashSet;
import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.analyser.*;
import abs.frontend.typechecker.*;
import java.util.Collections;
import java.util.Map;
import abs.common.*;
import abs.frontend.typechecker.Type;
import abs.frontend.typechecker.DataTypeType;
import abs.frontend.ast.InterfaceDecl;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.frontend.parser.*;
import abs.frontend.mtvl.ChocoSolver;
import choco.Choco;
import choco.kernel.model.constraints.Constraint;
import choco.kernel.model.variables.integer.IntegerVariable;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;
import abs.frontend.mtvl.Types;
import abs.frontend.parser.ParserError;
import java.util.*;
import java.util.regex.*;
import abs.frontend.tests.*;
import abs.frontend.treecopy.ParseTreeCopyHelper;
import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.TypeCheckerHelper;
import abs.frontend.typechecker.KindedName;
import abs.frontend.typechecker.ResolvedName;
import javax.annotation.CheckForNull;
import abs.frontend.typechecker.KindedName.Kind;
import java.util.Arrays;
import abs.frontend.typechecker.ext.*;
/**
 * @ast node
 * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/ast/SQL.ast:7
 * @production SqlExp : {@link EffExp};

 */
public abstract class SqlExp extends EffExp implements Cloneable {
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:7
   */
  public void generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
	{
		throw new NotImplementedYetException(this);
	}
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:12
   */
  public int numberOfRandom(Set<String> visitedFunctions) {
		return 0;
	}
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:16
   */
  public void generateScala(String prefix, PrintWriter output, List<Annotation> annotations) {
		throw new NotImplementedYetException(this);
	}
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:20
   */
  public void generateJava(PrintStream s) {
		// never called for processed ASTs
	}
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:24
   */
  public void generateJavaDynamic(PrintStream s) {
        // never called for processed ASTs
    }
  /**
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:28
   */
  public boolean isSuspendable(List<Annotation> annotations) {
        return false;
    }
  /**
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:24
   */
  protected PureExp refined_SqlRewrites_SqlExp_getDbExp(List<Stmt> newStmts, Set<String> occupiedVariables) {
        PureExp exp = activeDbConnection();
        if (exp != null)
            return exp;
        exp = activeDbTransaction();
        if (exp == null)
            return null;
        return CompilerUtils.copyPosition(exp, new FnApp(Constants.DB_TRANSACTIONS_LIB_NAME
                + ".transactionDb", new List<PureExp>().add((PureExp) exp.fullCopy())));
	}
  /**
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:36
   */
  @SuppressWarnings("unchecked")
	private void replaceThis(final ASTNode newNode) {
	    final ASTNode parent = getParent();
	    if (parent == null)
	        throw new RuntimeException("Trying to evaluate attribute in subtree not attached to main tree");
	    final int index = parent.getIndexOfChild(this);
	    // TODO: Use setChild?
	    parent.removeChild(index);
	    parent.insertChild(newNode, index);
	}
  /**
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:395
   */
  protected boolean isSqlSync() {
        final ASTNode asyncAnnotationNode = getNodeWithAnnotation("SqlAsync");
        if (asyncAnnotationNode == null)
            return true;
        final ASTNode syncAnnotationNode = getNodeWithAnnotation("SqlSync");
        if (syncAnnotationNode == null)
            return false;
        return ancestorDistance(syncAnnotationNode) < ancestorDistance(asyncAnnotationNode);
    }
  /**
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:411
   */
  public List<Stmt> rewriteToCoreAbs() throws abs.frontend.sql.SqlRewritingException {
        final List<Stmt> newStmts = new List<Stmt>();
        final Set<String> occupiedVariables = new HashSet<String>();
        final PureExp dbExp = getDbExp(newStmts, occupiedVariables);
        if (dbExp == null)
            throw new abs.frontend.sql.SqlRewritingException(new SemanticError(
                    this, ErrorMessage.SQL_NO_ACTIVE_DATABASE, new String[0]));
        final boolean sync = isSqlSync();
        ParametricDataTypeUse resultType = getSqlReturnTypeUse();
        if (!sync)
            resultType = new ParametricDataTypeUse(
                    Constants.STDLIB_NAME + ".Fut",
                    new List<Annotation>(),
                    new List<TypeUse>().add(resultType));
        // TODO fix getUnusedVarName so that it returns a really unused name
        final String resultVar = getUnusedVarName(occupiedVariables, "dbResult" + "_" + getStart() + "_%s");
        final List<Stmt> callStmts = createDbCalls(dbExp, sync, resultType, resultVar);
        replaceThis(new VarUse(resultVar));
        for (int i = 0; i < callStmts.getNumChildNoTransform(); i++)
            newStmts.add(callStmts.getChildNoTransform(i));
        return newStmts;
    }
  /**
   * Creates the calls which actually perform the database operation
   * represented by this expression. The result of the call must be saved in a
   * variable with name resultVar with type resultType.
   * 
   * The default implementation merely defines a VarDeclStmt which defines a new
   * variable and assigns the value returned by createDatabaseCall(...) which
   * itself uses the methods getSqlDbMethodName(...) and createSqlDbMethodArguments(...)
   * to obtain specialized call properties.
   * 
   * @param dbExp
   * the database expression which shall be used for calls
   * @param sync
   * whether the database calls shall be synchronous (true) or
   * asynchronous (false)
   * @param resultType
   * @param resultVar
   * @return the new statements which must at least contain a variable
   * declaration for the result variable
   * @throws SqlRewritingException
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:455
   */
  protected List<Stmt> createDbCalls(final PureExp dbExp, final boolean sync,
            final ParametricDataTypeUse resultType, final String resultVar) throws abs.frontend.sql.SqlRewritingException {
        return new List<Stmt>().add(CompilerUtils.copyPosition(this, new VarDeclStmt(
                new List<Annotation>(),
                CompilerUtils.copyPosition(this, new VarDecl(
                    resultVar,
                    resultType,
                    new Opt<Exp>(createDatabaseCall(dbExp, sync)))))));
    }
  /**
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:465
   */
  protected Call createDatabaseCall(PureExp dbExp, final boolean sync) throws abs.frontend.sql.SqlRewritingException {
        final PureExp transactionExp = activeDbTransaction();
        dbExp = (PureExp) dbExp.fullCopy();
        final String methodName = getSqlDbMethodName(transactionExp != null);
        final List<PureExp> arguments = createSqlDbMethodArguments(transactionExp);
        return CompilerUtils.copyPosition(this, sync ? new SyncCall(dbExp, methodName, arguments) :
            new AsyncCall(dbExp, methodName, arguments));
    }
  /**
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:476
   */
  protected abstract List<PureExp> createSqlDbMethodArguments(PureExp transactionExp) throws abs.frontend.sql.SqlRewritingException;
  /**
   * @declaredat ASTNode:1
   */
  public SqlExp() {
    super();
  }
  /**
   * Initializes the child array to the correct size.
   * Initializes List and Opt nta children.
   * @apilevel internal
   * @ast method
   * @declaredat ASTNode:10
   */
  public void init$Children() {
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:15
   */
  protected int numChildren() {
    return 0;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:21
   */
  public boolean mayHaveRewrite() {
    return false;
  }
  /**
   * @apilevel low-level
   * @declaredat ASTNode:27
   */
  public void flushCache() {
    super.flushCache();
    getType_visited = -1;
    getType_computed = false;
    getType_value = null;
    toSqlExp_visited = -1;
    isSqlExp_visited = -1;
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:38
   */
  public void flushCollectionCache() {
    super.flushCollectionCache();
  }
  /**
   * @apilevel internal
   * @declaredat ASTNode:44
   */
  public SqlExp clone() throws CloneNotSupportedException {
    SqlExp node = (SqlExp) super.clone();
    node.getType_visited = -1;
    node.getType_computed = false;
    node.getType_value = null;
    node.toSqlExp_visited = -1;
    node.isSqlExp_visited = -1;
    node.in$Circle(false);
    node.is$Final(false);
    return node;
  }
  /**
   * @aspect SqlProc
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlProc.jadd:90
   */
    protected PureExp getDbExp(List<Stmt> newStmts, Set<String> occupiedVariables) {
        if (getNodeWithAnnotation("SqlProc") == null)
            return refined_SqlRewrites_SqlExp_getDbExp(newStmts, occupiedVariables); 
        PureExp exp = activeDbConnection();
        if (exp == null)
            return null;
        // TODO fix getUnusedVarName
        final String dbVarName = getUnusedVarName(occupiedVariables, "dbExpression_" + getStart() + "_%s");
        newStmts.add(new VarDeclStmt(
            new List<Annotation>(),
            new VarDecl(
                dbVarName,
                new DataTypeUse(abs.common.Constants.DBLIB_NAME + ".RelationalTransactionalDatabase", new List<Annotation>()),
                new Opt<Exp>(CompilerUtils.copyPosition(exp, new SyncCall(
                    (PureExp) exp.fullCopy(),
                    "getWrappee",
                    new List<PureExp>()))))));
        return new VarUse(dbVarName);
    }
  /**
   * @attribute syn
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:474
   */
  public abstract ParametricDataTypeUse getSqlReturnTypeUse();
  /**
   * @attribute syn
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:475
   */
  public abstract String getSqlDbMethodName(boolean inTransaction);
  /**
   * @apilevel internal
   */
  protected int getType_visited = -1;
  /**
   * @apilevel internal
   */
  protected boolean getType_computed = false;
  /**
   * @apilevel internal
   */
  protected Type getType_value;
  /**
   * @attribute syn
   * @aspect SQL
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/Sql.jadd:3
   */
  public Type getType() {
    if(getType_computed) {
      return getType_value;
    }
    ASTNode$State state = state();
    if (getType_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: getType in class: org.jastadd.ast.AST.SynDecl");
    }
    getType_visited = state().boundariesCrossed;
    int num = state.boundariesCrossed;
    boolean isFinal = this.is$Final();
    getType_value = getType_compute();
    if(isFinal && num == state().boundariesCrossed) {
      getType_computed = true;
    } else {
    }

    getType_visited = -1;
    return getType_value;
  }
  /**
   * @apilevel internal
   */
  private Type getType_compute() {
  	   return null; // not be needed after rewriting
  	}
  /**
   * @apilevel internal
   */
  protected int toSqlExp_visited = -1;
  /**
   * @attribute syn
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:3
   */
  public SqlExp toSqlExp() {
    ASTNode$State state = state();
    if (toSqlExp_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: toSqlExp in class: org.jastadd.ast.AST.SynDecl");
    }
    toSqlExp_visited = state().boundariesCrossed;
    try {  return this;  }
    finally {
      toSqlExp_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  protected int isSqlExp_visited = -1;
  /**
   * @attribute syn
   * @aspect SqlRewrites
   * @declaredat /Users/vmastand/Documents/JavaProject/ABS/abstools/frontend/src/abs/frontend/sql/SqlRewrites.jrag:6
   */
  public boolean isSqlExp() {
    ASTNode$State state = state();
    if (isSqlExp_visited == state().boundariesCrossed) {
      throw new RuntimeException("Circular definition of attr: isSqlExp in class: org.jastadd.ast.AST.SynDecl");
    }
    isSqlExp_visited = state().boundariesCrossed;
    try {  return true;  }
    finally {
      isSqlExp_visited = -1;
    }
  }
  /**
   * @apilevel internal
   */
  public ASTNode rewriteTo() {    return super.rewriteTo();
  }}
